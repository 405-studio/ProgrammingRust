\chapter{运算符重载}\label{ch12}

在\hyperref[ch02]{第2章}的曼德勃罗集绘制器中，我们使用了\texttt{num} crate的\texttt{Complex}类型来表示一个复平面中的点：
\begin{minted}{Rust}
    #[derive(Clone, Copy, Debug)]
    struct Complex<T> {
        /// 复数的实部
        re: T,

        /// 复数的虚部
        im: T,
    }
\end{minted}

我们可以使用Rust的\texttt{+}和\texttt{*}运算符，像操作内建类型一样把\texttt{Complex}值相加和相乘：
\begin{minted}{Rust}
    z = z * z + c;
\end{minted}

你也可以让你自己的类型支持算数和其他运算符，只需要实现一些内建的trait。这被称为\emph{运算符重载(operator overloading)}，它的效果也类似于C++、C\#、Python和Ruby中的运算符重载。

如\hyperref[t12-1]{表12-1}所示，这些用于重载运算符的trait根据支持的语言部分被分为几个类别。在本章中，我们将介绍每一种类别。我们的目的不只是帮你把自己的类型漂亮地集成到语言中，还是为了让你更好地了解如何编写使用这些运算符的泛型函数，例如在“\nameref{RevBound}”中介绍的点积函数。本章还会深入了解语言某些功能本身是如何实现的。

\begin{table}[htbp]
    \centering
    \caption{运算符重载的trait汇总}
    \label{t12-1}
    \begin{tabular}{lll}
        \hline
        \textbf{类别}   & \textbf{trait}    & \textbf{运算符}   \\
        \hline

        \multirow{2}{*}{一元运算符} & \texttt{std::ops::Neg}    & \texttt{-x}   \\
        & \texttt{std::ops::Not} \cellcolor{tablecolor} & \texttt{!x} \cellcolor{tablecolor}  \\
        \hline

        \multirow{5}{*}{算术运算符} & \texttt{std::ops::Add}    & \texttt{x + y}\\
        & \texttt{std::ops::Sub} \cellcolor{tablecolor} & \texttt{x - y} \cellcolor{tablecolor} \\
        & \texttt{sdt::ops::Mul}    & \texttt{x * y}\\
        & \texttt{std::ops::Div} \cellcolor{tablecolor} & \texttt{x / y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::Rem}    & \texttt{x \% y}   \\
        \hline
        
        \multirow{5}{*}{位运算符}   & \texttt{std::ops::BitAnd} \cellcolor{tablecolor} & \texttt{x \& y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::BitOr}  & \texttt{x | y}    \\
        & \texttt{std::ops::BitXor} \cellcolor{tablecolor} & \texttt{x \^{} y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::Shl}    & \texttt{x << y}   \\
        & \texttt{std::ops::Shr}    \cellcolor{tablecolor} & \texttt{x >> y} \cellcolor{tablecolor} \\
        \hline

        \multirow{5}{*}{复合赋值算术运算符}  & \texttt{std::ops::AddAssign} & \texttt{x += y} \\
        & \texttt{std::ops::SubAssign} \cellcolor{tablecolor} & \texttt{x -= y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::MulAssign}  & \texttt{x *= y}  \\
        & \texttt{std::ops::DivAssign} \cellcolor{tablecolor} & \texttt{x /= y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::RemAssign}  & \texttt{x \%= y} \\
        \hline

        \multirow{5}{*}{复合赋值位运算符} & \texttt{std::ops::BitAndAssign} \cellcolor{tablecolor} & \texttt{x \&= y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::BitOrAssign}& \texttt{x |= y} \\
        & \texttt{std::ops::BitXorAssign} \cellcolor{tablecolor} & \texttt{x \^{}= y} \cellcolor{tablecolor} \\
        & \texttt{std::ops::ShlAssign}  & \texttt{x <<= y} \\
        & \texttt{std::ops::ShrAssign}    \cellcolor{tablecolor} & \texttt{x >>= y}   \cellcolor{tablecolor} \\
        \hline

        \multirow{2}{*}{比较}   & \texttt{std::cmp::PartialEq}  & \texttt{x == y, x != y}   \\
        & \texttt{std::cmp::PartialOrd} \cellcolor{tablecolor} & \texttt{x < y, x <= y, x > y, x >= y} \cellcolor{tablecolor} \\
        \hline

        \multirow{2}{*}{索引}   & \texttt{std::ops::Index}  & \texttt{x[y], \&x[y]} \\
        & \texttt{std::ops::IndexMut} \cellcolor{tablecolor} & \texttt{x[y] = z, \&mut x[y]} \cellcolor{tablecolor} \\
    \end{tabular}
\end{table}

\section{算术和位运算符}

在Rust中，表达式\texttt{a + b}实际上是\texttt{a.add(b)}的缩写，即对标准库中的\texttt{std::ops::Add} trait的\texttt{add}方法的调用。Rust的标准数值类型都实现了\texttt{std::ops::Add}。为了让表达式\texttt{a + b}能用于\texttt{Complex}类型的值，\texttt{num} crate为\texttt{Complex}类型实现了这个trait。其他运算符也有类似的trait：\texttt{a * b}是\texttt{a.mul(b)}的缩写，这个方法来自\texttt{std::ops::Mul} trait，\texttt{std::ops::Neg}包含取负数运算符，等等。

如果你想尝试写\texttt{z.add(c)}，你需要在作用域中引入\texttt{Add} trait，这样这个方法才可见。然后，你就可以把所有算术看作函数调用：\footnote{Lisp程序员狂喜！表达式\texttt{<i32 as Add>::add}是\texttt{i32}的\texttt{+}运算符，被捕获为函数类型的值。}

\begin{minted}{Rust}
    use std::ops::Add;

    assert_eq!(4.125f32.add(5.75), 9.875);
    assert_eq!(10.add(20), 10 + 20);
\end{minted}

这时\texttt{std::ops::Add}的定义：
\begin{minted}{Rust}
    trait Add<Rhs = Self> {
        type Output;
        fn add(self, rhs: Rhs) -> Self::Output;
    }
\end{minted}

换句话说，\texttt{Add<T>} trait让你的类型可以加上\texttt{T}类型的值。例如，为了让你的类型能加上\texttt{i32}和\texttt{u32}，你的类型必须实现了\texttt{Add<i32>}和\texttt{Add<u32>}。trait的类型参数\texttt{Rhs}默认是\texttt{Self}，因此如果你想实现两个相同类型的值的加法，可以直接实现\texttt{Add} trait。关联类型\texttt{Output}表示加法结果的类型。

例如，为了能把\texttt{Complex<i32>}值相加，\texttt{Complex<i32>}必须实现\texttt{Add<Complex<i32>>}。因为我们是把一个类型加到同类型的值上，所以可以简单地写\texttt{Add}：
\begin{minted}{Rust}
    use std::ops::Add;

    impl Add for Complex<i32> {
        type Output = Complex<i32>;
        fn add(self, rhs: Self) -> Self {
            Complex {
                re: self.re + rhs.re,
                im: self.im + rhs.im,
            }
        }
    }
\end{minted}

当然，我们不需要单独为\texttt{Complex<i32>}、\texttt{Complex<f32>}、\texttt{Complex<f64>}等实现\texttt{Add}。除了类型不同以外所有的定义看起来完全相同，所以我们可以写一个覆盖所有情况的泛型实现，只要实部和虚部的类型支持加法：
\begin{minted}{Rust}
    impl<T> Add for Complex<T>
    where
        T: Add<Output = T>,
    {
        type Output = Self;
        fn add(self, rhs: Self) -> Self {
            Complex {
                re: self.re + rhs.re,
                im: self.im + rhs.im,
            }
        }
    }
\end{minted}

通过\texttt{where T: Add<Output = T>}，我们可以把\texttt{T}限制为可以与同类型的值相加并且返回同类型的值的类型。这个限制是有原因的，但我们可以进一步放松限制：\texttt{Add} trait并不要求\texttt{+}两侧的操作数类型相同，也不需要返回相同的类型。因此一个最大限度的泛型实现可以让左边的操作数和右边的操作数类型不同，并让返回值中的实部和虚部的类型是加法返回的类型：
\begin{minted}{Rust}
    use std::ops::Add;
    impl<L, R> Add<Complex<R>> for Complex<L>
        where L: Add<R>
    {
        type Output = Complex<L::Output>;
        fn add(self, rhs: Complex<R>) -> Self::Output {
            Complex {
                re: self.re + rhs.re,
                im: self.im + rhs.im,
            }
        }
    }
\end{minted}

然而，在实践中，Rust尝试避免支持混合类型的操作，因此我们的类型参数\texttt{L}必须实现\texttt{Add<R>}。一般来说\texttt{L}和\texttt{R}是相同类型：并没有多少类型遵循\texttt{L}实现的这种逻辑。因此到最后，这个极致泛型化的版本可能并不比之前更简单的泛型定义版本有用。

Rust中为算术和位运算符设计的内建trait被分为三组：一元运算符、二元运算符和复合赋值运算符。每个组中的所有trait和它们的方法的形式都相同，因此我们会从中挑选一个作为示例。

\subsection{一元运算符}\label{unop}
除了解引用运算符\texttt{*}将在“\nameref{deref}”一节中单独介绍之外，Rust还有可以自定义的一元运算符，如\hyperref[t12-2]{表12-2}所示。

\begin{table}[htbp]
    \centering
    \caption{内建的一元运算符的trait}
    \label{t12-2}
    \begin{tabular}{p{0.3\textwidth}p{0.3\textwidth}p{0.3\textwidth}}
        \hline
        \textbf{trait名称}  & \textbf{表达式}   & \textbf{等价的表达式} \\
        \hline
        \texttt{std::ops::Neg}  & \texttt{-x}   & \texttt{x.neg()}  \\
        \rowcolor{tablecolor}
        \texttt{std::ops::Not}  & \texttt{!x}   & \texttt{x.not()}  \\
    \end{tabular}
\end{table}

所有Rust的有符号数值类型都实现了\texttt{std::ops::Neg}，用于一元运算符\texttt{-}。整数类型和\texttt{bool}类型实现了\texttt{std::ops::Not}，用于一元运算符\texttt{!}。这些类型的引用也有相应的实现。

注意\texttt{!}会按位取反整数（即反转所有位）值、反转\texttt{bool}值。它同时提供C和C++中的\texttt{!}和\texttt{~}的功能。

这些trait的定义很简单：
\begin{minted}{Rust}
    trait Neg {
        type Output;
        fn neg(self) -> Self::Output;
    }

    trait Not {
        type Output;
        fn not(self) -> Self::Output;
    }
\end{minted}

求一个复数值的负数只需要简单的求它的每个部分的负数。这里我们可以为\texttt{Complex}值写一个泛型的求负数实现：
\begin{minted}{Rust}
    use std::ops::Neg;

    impl<T> Neg for Complex<T>
    where
        T: Neg<Output = T>,
    {
        type Output = Complex<T>;
        fn neg(self) -> Complex<T> {
            Complex {
                re: -self.re,
                im: -self.im,
            }
        }
    }
\end{minted}

\subsection{二元运算符}\label{biop}


\subsection{复合赋值运算符}\label{assign}

\section{相等比较}\label{equal}

\section{顺序比较}\label{cmp}

\section{Index与IndexMut}\label{index}
