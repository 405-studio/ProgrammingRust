\chapter{unsafe代码}\label{ch22}

\emph{Let no one think of me that I am humble or weak or passive; \\
Let them understand I am of a diﬀerent kind: dangerous to my enemies, loyal to my friends. \\
To such a life glory belongs.}

系统级编程的乐趣在于，在每一个安全的语言和精心设计的抽象之下，都是不安全的机器语言和比特位。你也可以在Rust中写出这样的代码。

到目前为止本书中介绍的语言部分，例如类型、生命周期、约束检查等都可以自动保证你的程序完全没有内存错误和数据竞争。但这种自动的技术有它的局限性；Rust并不能识别出来很多有价值的技术是安全的。

\emph{unsafe代码}让你可以告诉Rust，“我要使用一些你不能保证安全的特性”。把一个块或者函数标记为unsafe之后，你就可以调用标准库中的\texttt{unsafe}函数、解引用unsafe指针、调用其他语言例如C和C++编写的函数等。Rust的其他安全性检查依然生效：类型检查、生命周期检查、约束检查等仍然和之前一样。unsafe代码只是允许了一小部分额外的特性。

正是因为有了允许超出safe Rust界限的能力，Rust才能实现它自身的大部分基础特性，和C/C++一样，Rust也被用来实现它自己的标准库。unsafe代码可以让\texttt{Vec}类型更高效地管理它的缓冲区；让\texttt{std::io}模块和操作系统交互；让\texttt{std::thread}和\texttt{std::sync}模块提供并发原语。

本章介绍了unsafe特性的一些基础：

\begin{enumerate}
    \item Rust的\texttt{unsafe}块区分开了普通的safe Rust代码和使用unsafe特性的代码。
    \item 你可以把函数标记为\texttt{unsafe}，提醒调用者他们必须遵守的一些额外约束来避免未定义行为。
    \item 原始指针和它们的方法运行对内存进行不受限的访问，并允许你构建Rust的类型系统可能禁止的数据结构。Rust的引用虽然安全，但却是受限制的，原始指针正如每个C或C++程序员所知，是一个强大而锋利的工具。
    \item 理解未定义行为的定义将会帮助你理解为什么它们比得到错误结果还要糟糕的多。
    \item unsafe trait，类似于\texttt{unsafe}函数，隐含了每个实现（而不是每个调用者）都要遵守的规则。
\end{enumerate}

\section{unsafe从何而来？}
在本书的开头处，我们曾经展示过一个C程序，它以一种非常令人惊讶的方式崩溃。这是因为它违背了C标准的一个规则。你可以在Rust中实现相同的效果：

\begin{minted}{bash}
    $cat crash.rs
    fn main() {
        let mut a: usize = 0;
        let ptr = &mut a as *mut usize;
        unsafe {
            *ptr.offset(3) = 0x7ffff72f484c;
        }
    }
    $ cargo build
       Compiling unsafe-samples v0.1.0
        Finished debug [unoptimized + debuginfo] target(s) in 0.44s
    $ ../../target/debug/crash
    crash: Error: .netrc file is readable by others.
    crash: Remove password or make file unreadable by others.
    Segmentation fault (core dumped)
    $
\end{minted}

这个程序借用了局部变量\texttt{a}的一个可变引用，然后把它转换成了\texttt{*mut usize}类型的原始指针，然后使用了它的\texttt{offset}方法来产生一个指向三个字之后的位置的指针。这里恰巧存储了\texttt{main}的返回地址。这个程序用一个常量覆盖了返回地址，因此从\texttt{main}返回之后程序的行为就很奇怪。这个崩溃之所以可行，是因为程序错误使用了unsafe的特性——在这个例子中，就是解引用原始指针的能力。

一个unsafe特性通常隐含了一份\emph{合约（contract）}：即一组Rust不能自动强制，但你必须遵守才能避免\emph{未定义行为}的规则。

一份合约超出了普通的类型检查和生命周期检查，它们隐含着一些unsafe特性特定的规则。通常来说，Rust本身完全不知道这些合约，它们只在unsafe特性的文档里得到解释。例如，原始指针类型的合约是禁止解引用一个指向的位置超出原来指向物的末尾的原始指针。这个例子中的表达式\texttt{*ptr.offset(3) = ...}打破了这个合约。但是，正如上面所示，Rust没有任何警告，成功编译了这个程序：它的安全检查并没有检测出来这个违规行为。当你使用unsafe特性时，你作为程序员，需要负责检查你的代码遵守了它们的合约。

很多特性如果想正确使用，都要遵守一定的规则。但这些规则并不是我们这里说的合约，除非它们可能会导致未定义行为。未定义行为是一种Rust假设你的代码中绝对不会出现的行为。例如，Rust假设你不会用别的值覆盖函数的返回地址。通过了Rust通常的安全检查并且遵守了使用到的unsafe特性的合约的代码不可能会出现这样的行为。因为这个程序违反了原始指针的合约，因此它的行为变得未定义，并最终崩溃。

如果你的代码出现了未定义行为，说明你打破了你负责的一部分，Rust拒绝预测结果。从系统库的深处抛出来一个错误并崩溃是一种可能的结果；把你的计算机的控制权交给攻击者是另一种可能的结果。不同的Rust版本可能也会有不同的行为。然而，有时未定义行为不一定会产生可见的结果。例如，如果这里的\texttt{main}函数永远不会返回（可能调用了\texttt{std::process::exit}）来提前终止程序），那么错误的返回地址也无关紧要。

你只能在\texttt{unsafe}块或者\texttt{unsafe}函数里使用unsafe特性；我们将在接下来的小节介绍它们。它们让unsafe特性不容易被忽略：通过强迫你写一个\texttt{unsafe}块或者函数，Rust能确保你知道你的代码可能要遵守一些额外的规则。

\section{unsafe块}
\texttt{unsafe}块看起来就像一个以\texttt{unsafe}关键字开头的普通块，区别在于你可以在unsafe块里使用unsafe特性：
\begin{minted}{Rust}
    unsafe {
        String::from_utf8_unchecked(ascii)
    }
\end{minted}

如果没有块前面的\texttt{unsafe}关键字，Rust将会禁止使用\texttt{from\_utf8\_unchecked}，因为它是一个\texttt{unsafe}的函数。在\texttt{unsafe}块中，你可以随意使用它。

和普通的Rust块一样，\texttt{unsafe}块的值也是最后一条表达式的值，或者是\texttt{()}。这个例子中\texttt{String::from\_utf8\_unchecked}的调用提供了块的值。

一个\texttt{unsafe}块为你解锁了5个额外的功能：
\begin{enumerate}
    \item 你可以调用\texttt{unsafe}函数。每一个\texttt{unsafe}函数都有它自己的合约，这取决于它的功能。
    \item 你可以解引用原始指针。safe代码可以传递、比较、通过引用转换创建原始指针，但只有unsafe代码才可以使用它们来访问内存。我们将在\nameref{rawp}中详细介绍原始指针并解释如何安全地使用它们。
    \item 你可以访问\texttt{union}的字段，尽管编译器不能确定它们含有相应类型的有效值。
    \item 你可以访问可变的\texttt{static}变量。正如\nameref{globalvar}中解释的一样，Rust不能确保什么时候有线程正在使用可变的\texttt{static}变量，因此它们的合约要求你要确保所有的访问都是正确同步的。
    \item 你可以访问通过Rust的外部函数接口声明的函数和变量。即使它们是不可变的，也会被认为是\texttt{unsafe}的，因为它们是使用其他语言编写的，这些语言可能不遵守Rust的安全规则。
\end{enumerate}

把unsafe特性约束在\texttt{unsafe}块里并不会真的阻止你做任何想做的事。你完全只需要在你的代码里加上一个\texttt{unsafe}块，然后就可以继续了。这个规则的作用主要是为了把人类的注意力吸引到那些Rust不能保证安全性的代码上：
\begin{enumerate}
    \item 你不会意外地使用到unsafe特性，然后发现你要为甚至不知道它的存在的合约负责。
    \item 一个\texttt{unsafe}块可以吸引reviewer更多的注意力。一些项目甚至有一些自动化流程来确保这一点，例如标记出会影响\texttt{unsafe}块的代码来吸引更多注意力。
    \item 当你正在考虑编写一个\texttt{unsafe}块时，你可以花费一点时间来问问自己你的任务是否真的需要这些特性。如果是为了性能，你是否有测量数据表明这真的是一个性能瓶颈？可能有一种在safe Rust中也可以实现相同效果的方法。
\end{enumerate}

\section{示例：一个高效的ASCII字符类型}
这里有一个示例，\texttt{Ascii}是一个字符串类型，它确保它的内容总是有效的ASCII字符。这个类型使用一个unsafe特性来提供到\texttt{String}的0开销转换：
\begin{minted}{Rust}
    mod my_ascii {
        /// 一个ASCII编码的字符串
        #[derive(Debug, Eq, PartialEq)]
        pub struct Ascii(
            // 它必须只存有有效的ASCII文本：从`0`到`0x7f`的字节序列
            Vec<u8>
        );

        impl Ascii {
            /// 从`bytes`中的Ascii文本创建一个`Ascii`。
            /// 如果`bytes`中含有任何非ASCII字符就返回一个`NotAsciiError`错误。
            pub fn from_bytes(bytes: Vec<u8>) -> Result<Ascii, NotAsciiError> {
                if bytes.iter().any(|&byte| !byte.is_ascii()) {
                    return Err(NotAsciiError(bytes));
                }
                Ok(Ascii(bytes))
            }
        }

        // 当转换失败时，我们会给出不能转换的vector。
        // 它应该实现`std::error::Error`，这里为了简洁就省略了。
        #[derive(Debug, Eq, PartialEq)]
        pub struct NotAsciiError(pub Vec<u8>);

        // 安全、高效的转换，使用unsafe代码实现。
        impl From<Ascii> for String {
            fn from(ascii: Ascii) -> String {
                // 如果这个模块没有bug的话，这里就是安全的，
                // 因为有效的ASCII文本也是有效的UTF-8文本。
                unsafe { String::from_utf8_unchecked(ascii.0) }
            }
        }
        ...
    }
\end{minted}

这个模块的关键是\texttt{Ascii}类型的定义。这个类型本身被标记为\texttt{pub}，来让它在\texttt{my\_ascii}模块外可见。但它的\texttt{Vec<u8>}元素\emph{不是}public的，因此只有\texttt{my\_ascii}模块里的方法可以创建一个\texttt{Ascii}值或者访问它的元素。这完全控制了模块里哪些代码是公开的哪些是不公开的。只要public的构造器和方法能确保新创建的\texttt{Ascii}值是有效的，并始终保持有效，那么程序的其他部分就不可能违反规则。并且public的构造器\texttt{Ascii::from\_bytes}确实小心地检查了给定的vector来确保能从它构建出一个有效的\texttt{Ascii}。出于简洁性的考虑，我们并没有展示出每一个方法，但你可以想象还有一些处理文本的方法，这些方法同样确保\texttt{Ascii}的值总是有效的ASCII文本，就像\texttt{String}的方法确保它的内容总是有效的UTF-8.

这样的安排让我们可以非常高效地为\texttt{String}实现\texttt{From<Ascii>}。unsafe函数\texttt{String::from\_utf8\_unchecked}获取一个字节vector并根据它的内容构建一个\texttt{String}，并且不检查它的内容是否是有效的UTF-8文本；这个函数的合约就是调用者要负责这一点。幸运的是，\texttt{Ascii}类型强迫的规则正是满足\texttt{from\_utf8\_unchecked}的合约所需的条件。正如我们在\nameref{utf8}中解释的一样，任何有效的ASCII文本都是有效的UTF-8文本，因此\texttt{Ascii}内部的\texttt{Vec<u8>}可以立刻作为一个\texttt{String}的缓冲区使用。

有了这些定义之后，你可以写这样的代码：
\begin{minted}{Rust}
    use my_ascii::Ascii;

    let bytes: Vec<u8> = b"ASCII and ye shall receive".to_vec();

    // 这里的调用没有任何内存分配或者文本拷贝，只进行一次扫描。
    let ascii: Ascii = Ascii::from_bytes(bytes)
        .unwrap();  // 我们已经知道了bytes是没问题的。

    // 这里的调用是0开销的：没有内存分配、拷贝、扫描。
    let string = String::from(ascii);

    assert_eq!(string, "ASCII and ye shall receive");
\end{minted}

使用\texttt{Ascii}不需要unsafe块。我们已经使用unsafe操作实现了一个safe的接口，并且安排好只依赖模块自己的代码而不是用户的行为来满足它的合约。

\texttt{Ascii}只是一个\texttt{Vec<u8>}的包装，并在模块里隐藏了一些强迫它的内容需要满足的规则。一个这样的类型被称为\emph{newtype}，它是Rust中非常普遍的一种模式。Rust自己的\texttt{String}类型就使用完全相同的方式定义的，区别只有它的内容被限制为UTF-8，而不是ASCII。事实上，这是标准库里\texttt{String}的定义：
\begin{minted}{Rust}
    pub struct String {
        vec: Vec<u8>,
    }
\end{minted}

在机器语言的层面上，是完全没有Rust的类型信息的，一个newtype和它的元素有完全相同的内存表示，因此构建一个newtype完全不需要任何额外的机器指令。在\texttt{Ascii::from\_bytes}中，表达式\texttt{Ascii(bytes)}只是表明\texttt{Vec<u8>}现在的内存表示持有的是一个\texttt{Ascii}值。类似的，\texttt{String::from\_utf8\_unchecked}在内联的情况下可能不包含任何机器指令：它只表明\texttt{Vec<u8>}现在被认为是一个\texttt{String}。

\section{unsafe函数}


\section{原始指针}\label{rawp}

