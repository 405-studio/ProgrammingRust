\chapter{unsafe代码}\label{ch22}

\emph{Let no one think of me that I am humble or weak or passive; \\
Let them understand I am of a diﬀerent kind: dangerous to my enemies, loyal to my friends. \\
To such a life glory belongs.}

系统级编程的乐趣在于，在每一个安全的语言和精心设计的抽象之下，都是不安全的机器语言和比特位。你也可以在Rust中写出这样的代码。

到目前为止本书中介绍的语言部分，例如类型、生命周期、约束检查等都可以自动保证你的程序完全没有内存错误和数据竞争。但这种自动的技术有它的局限性；Rust并不能识别出来很多有价值的技术是安全的。

\emph{unsafe代码}让你可以告诉Rust，“我要使用一些你不能保证安全的特性”。把一个块或者函数标记为unsafe之后，你就可以调用标准库中的\texttt{unsafe}函数、解引用unsafe指针、调用其他语言例如C和C++编写的函数等。Rust的其他安全性检查依然生效：类型检查、生命周期检查、约束检查等仍然和之前一样。unsafe代码只是允许了一小部分额外的特性。

正是因为有了允许超出safe Rust界限的能力，Rust才能实现它自身的大部分基础特性，和C/C++一样，Rust也被用来实现它自己的标准库。unsafe代码可以让\texttt{Vec}类型更高效地管理它的缓冲区；让\texttt{std::io}模块和操作系统交互；让\texttt{std::thread}和\texttt{std::sync}模块提供并发原语。

本章介绍了unsafe特性的一些基础：

\begin{enumerate}
    \item Rust的\texttt{unsafe}块区分开了普通的safe Rust代码和使用unsafe特性的代码。
    \item 你可以把函数标记为\texttt{unsafe}，提醒调用者他们必须遵守的一些额外约束来避免未定义行为。
    \item 原始指针和它们的方法运行对内存进行不受限的访问，并允许你构建Rust的类型系统可能禁止的数据结构。Rust的引用虽然安全，但却是受限制的，原始指针正如每个C或C++程序员所知，是一个强大而锋利的工具。
    \item 理解未定义行为的定义将会帮助你理解为什么它们比得到错误结果还要糟糕的多。
    \item unsafe trait，类似于\texttt{unsafe}函数，隐含了每个实现（而不是每个调用者）都要遵守的规则。
\end{enumerate}

\section{unsafe从何而来？}
在本书的开头处，我们曾经展示过一个C程序，它以一种非常令人惊讶的方式崩溃。这是因为它违背了C标准的一个规则。你可以在Rust中实现相同的效果：

\begin{minted}{bash}
    $cat crash.rs
    fn main() {
        let mut a: usize = 0;
        let ptr = &mut a as *mut usize;
        unsafe {
            *ptr.offset(3) = 0x7ffff72f484c;
        }
    }
    $ cargo build
       Compiling unsafe-samples v0.1.0
        Finished debug [unoptimized + debuginfo] target(s) in 0.44s
    $ ../../target/debug/crash
    crash: Error: .netrc file is readable by others.
    crash: Remove password or make file unreadable by others.
    Segmentation fault (core dumped)
    $
\end{minted}

这个程序借用了局部变量\texttt{a}的一个可变引用，然后把它转换成了\texttt{*mut usize}类型的原始指针，然后使用了它的\texttt{offset}方法来产生一个指向三个字之后的位置的指针。这里恰巧存储了\texttt{main}的返回地址。这个程序用一个常量覆盖了返回地址，因此从\texttt{main}返回之后程序的行为就很奇怪。这个崩溃之所以可行，是因为程序错误使用了unsafe的特性——在这个例子中，就是解引用原始指针的能力。

一个unsafe特性通常隐含了一份\emph{合约（contract）}：即一组Rust不能自动强制，但你必须遵守才能避免\emph{未定义行为}的规则。

一份合约超出了普通的类型检查和生命周期检查，它们隐含着一些unsafe特性特定的规则。通常来说，Rust本身完全不知道这些合约，它们只在unsafe特性的文档里得到解释。例如，原始指针类型的合约是禁止解引用一个指向的位置超出原来指向物的末尾的原始指针。这个例子中的表达式\texttt{*ptr.offset(3) = ...}打破了这个合约。但是，正如上面所示，Rust没有任何警告，成功编译了这个程序：它的安全检查并没有检测出来这个违规行为。当你使用unsafe特性时，你作为程序员，需要负责检查你的代码遵守了它们的合约。

很多特性如果想正确使用，都要遵守一定的规则。但这些规则并不是我们这里说的合约，除非它们可能会导致未定义行为。未定义行为是一种Rust假设你的代码中绝对不会出现的行为。例如，Rust假设你不会用别的值覆盖函数的返回地址。通过了Rust通常的安全检查并且遵守了使用到的unsafe特性的合约的代码不可能会出现这样的行为。因为这个程序违反了原始指针的合约，因此它的行为变得未定义，并最终崩溃。

如果你的代码出现了未定义行为，说明你打破了你负责的一部分，Rust拒绝预测结果。从系统库的深处抛出来一个错误并崩溃是一种可能的结果；把你的计算机的控制权交给攻击者是另一种可能的结果。不同的Rust版本可能也会有不同的行为。然而，有时未定义行为不一定会产生可见的结果。例如，如果这里的\texttt{main}函数永远不会返回（可能调用了\texttt{std::process::exit}）来提前终止程序），那么错误的返回地址也无关紧要。

你只能在\texttt{unsafe}块或者\texttt{unsafe}函数里使用unsafe特性；我们将在接下来的小节介绍它们。它们让unsafe特性不容易被忽略：通过强迫你写一个\texttt{unsafe}块或者函数，Rust能确保你知道你的代码可能要遵守一些额外的规则。

\section{unsafe块}
\texttt{unsafe}块看起来就像一个以\texttt{unsafe}关键字开头的普通块，区别在于你可以在unsafe块里使用unsafe特性：
\begin{minted}{Rust}
    unsafe {
        String::from_utf8_unchecked(ascii)
    }
\end{minted}

如果没有块前面的\texttt{unsafe}关键字，Rust将会禁止使用\texttt{from\_utf8\_unchecked}，因为它是一个\texttt{unsafe}的函数。在\texttt{unsafe}块中，你可以随意使用它。

和普通的Rust块一样，\texttt{unsafe}块的值也是最后一条表达式的值，或者是\texttt{()}。这个例子中\texttt{String::from\_utf8\_unchecked}的调用提供了块的值。

一个\texttt{unsafe}块为你解锁了5个额外的功能：
\begin{enumerate}
    \item 你可以调用\texttt{unsafe}函数。每一个\texttt{unsafe}函数都有它自己的合约，这取决于它的功能。
    \item 你可以解引用原始指针。safe代码可以传递、比较、通过引用转换创建原始指针，但只有unsafe代码才可以使用它们来访问内存。我们将在\nameref{rawp}中详细介绍原始指针并解释如何安全地使用它们。
    \item 你可以访问\texttt{union}的字段，尽管编译器不能确定它们含有相应类型的有效值。
    \item 你可以访问可变的\texttt{static}变量。正如\nameref{globalvar}中解释的一样，Rust不能确保什么时候有线程正在使用可变的\texttt{static}变量，因此它们的合约要求你要确保所有的访问都是正确同步的。
    \item 你可以访问通过Rust的外部函数接口声明的函数和变量。即使它们是不可变的，也会被认为是\texttt{unsafe}的，因为它们是使用其他语言编写的，这些语言可能不遵守Rust的安全规则。
\end{enumerate}

把unsafe特性约束在\texttt{unsafe}块里并不会真的阻止你做任何想做的事。你完全只需要在你的代码里加上一个\texttt{unsafe}块，然后就可以继续了。这个规则的作用主要是为了把人类的注意力吸引到那些Rust不能保证安全性的代码上：
\begin{enumerate}
    \item 你不会意外地使用到unsafe特性，然后发现你要为甚至不知道它的存在的合约负责。
    \item 一个\texttt{unsafe}块可以吸引reviewer更多的注意力。一些项目甚至有一些自动化流程来确保这一点，例如标记出会影响\texttt{unsafe}块的代码来吸引更多注意力。
    \item 当你正在考虑编写一个\texttt{unsafe}块时，你可以花费一点时间来问问自己你的任务是否真的需要这些特性。如果是为了性能，你是否有测量数据表明这真的是一个性能瓶颈？可能有一种在safe Rust中也可以实现相同效果的方法。
\end{enumerate}

\section{示例：一个高效的ASCII字符类型}
这里有一个示例，\texttt{Ascii}是一个字符串类型，它确保它的内容总是有效的ASCII字符。这个类型使用一个unsafe特性来提供到\texttt{String}的0开销转换：
\begin{minted}{Rust}
    mod my_ascii {
        /// 一个ASCII编码的字符串
        #[derive(Debug, Eq, PartialEq)]
        pub struct Ascii(
            // 它必须只存有有效的ASCII文本：从`0`到`0x7f`的字节序列
            Vec<u8>
        );

        impl Ascii {
            /// 从`bytes`中的Ascii文本创建一个`Ascii`。
            /// 如果`bytes`中含有任何非ASCII字符就返回一个`NotAsciiError`错误。
            pub fn from_bytes(bytes: Vec<u8>) -> Result<Ascii, NotAsciiError> {
                if bytes.iter().any(|&byte| !byte.is_ascii()) {
                    return Err(NotAsciiError(bytes));
                }
                Ok(Ascii(bytes))
            }
        }

        // 当转换失败时，我们会给出不能转换的vector。
        // 它应该实现`std::error::Error`，这里为了简洁就省略了。
        #[derive(Debug, Eq, PartialEq)]
        pub struct NotAsciiError(pub Vec<u8>);

        // 安全、高效的转换，使用unsafe代码实现。
        impl From<Ascii> for String {
            fn from(ascii: Ascii) -> String {
                // 如果这个模块没有bug的话，这里就是安全的，
                // 因为有效的ASCII文本也是有效的UTF-8文本。
                unsafe { String::from_utf8_unchecked(ascii.0) }
            }
        }
        ...
    }
\end{minted}

这个模块的关键是\texttt{Ascii}类型的定义。这个类型本身被标记为\texttt{pub}，来让它在\texttt{my\_ascii}模块外可见。但它的\texttt{Vec<u8>}元素\emph{不是}public的，因此只有\texttt{my\_ascii}模块里的方法可以创建一个\texttt{Ascii}值或者访问它的元素。这完全控制了模块里哪些代码是公开的哪些是不公开的。只要public的构造器和方法能确保新创建的\texttt{Ascii}值是有效的，并始终保持有效，那么程序的其他部分就不可能违反规则。并且public的构造器\texttt{Ascii::from\_bytes}确实小心地检查了给定的vector来确保能从它构建出一个有效的\texttt{Ascii}。出于简洁性的考虑，我们并没有展示出每一个方法，但你可以想象还有一些处理文本的方法，这些方法同样确保\texttt{Ascii}的值总是有效的ASCII文本，就像\texttt{String}的方法确保它的内容总是有效的UTF-8.

这样的安排让我们可以非常高效地为\texttt{String}实现\texttt{From<Ascii>}。unsafe函数\texttt{String::from\_utf8\_unchecked}获取一个字节vector并根据它的内容构建一个\texttt{String}，并且不检查它的内容是否是有效的UTF-8文本；这个函数的合约就是调用者要负责这一点。幸运的是，\texttt{Ascii}类型强迫的规则正是满足\texttt{from\_utf8\_unchecked}的合约所需的条件。正如我们在\nameref{utf8}中解释的一样，任何有效的ASCII文本都是有效的UTF-8文本，因此\texttt{Ascii}内部的\texttt{Vec<u8>}可以立刻作为一个\texttt{String}的缓冲区使用。

有了这些定义之后，你可以写这样的代码：
\begin{minted}{Rust}
    use my_ascii::Ascii;

    let bytes: Vec<u8> = b"ASCII and ye shall receive".to_vec();

    // 这里的调用没有任何内存分配或者文本拷贝，只进行一次扫描。
    let ascii: Ascii = Ascii::from_bytes(bytes)
        .unwrap();  // 我们已经知道了bytes是没问题的。

    // 这里的调用是0开销的：没有内存分配、拷贝、扫描。
    let string = String::from(ascii);

    assert_eq!(string, "ASCII and ye shall receive");
\end{minted}

使用\texttt{Ascii}不需要unsafe块。我们已经使用unsafe操作实现了一个safe的接口，并且安排好只依赖模块自己的代码而不是用户的行为来满足它的合约。

\texttt{Ascii}只是一个\texttt{Vec<u8>}的包装，并在模块里隐藏了一些强迫它的内容需要满足的规则。一个这样的类型被称为\emph{newtype}，它是Rust中非常普遍的一种模式。Rust自己的\texttt{String}类型就使用完全相同的方式定义的，区别只有它的内容被限制为UTF-8，而不是ASCII。事实上，这是标准库里\texttt{String}的定义：
\begin{minted}{Rust}
    pub struct String {
        vec: Vec<u8>,
    }
\end{minted}

在机器语言的层面上，是完全没有Rust的类型信息的，一个newtype和它的元素有完全相同的内存表示，因此构建一个newtype完全不需要任何额外的机器指令。在\texttt{Ascii::from\_bytes}中，表达式\texttt{Ascii(bytes)}只是表明\texttt{Vec<u8>}现在的内存表示持有的是一个\texttt{Ascii}值。类似的，\texttt{String::from\_utf8\_unchecked}在内联的情况下可能不包含任何机器指令：它只表明\texttt{Vec<u8>}现在被认为是一个\texttt{String}。

\section{unsafe函数}
\texttt{unsafe}函数的定义就像一个以\texttt{unsafe}开头的普通函数。\texttt{unsafe}函数的函数体自动被认为是一个\texttt{unsafe}块。

你只能在\texttt{unsafe}块里调用\texttt{unsafe}函数。这意味着将一个函数标记为\texttt{unsafe}可以警告调用者这个函数有一个额外的合约，必须满足这个合约才能避免未定义行为。

例如，这里有一个新的\texttt{Ascii}类的构造器，这个构造器从一个字节vector构建一个\texttt{Ascii}，并且不检查内容是否是有效的ASCII：
\begin{minted}{Rust}
    // 这段代码必须放在`my_ascii`模块中。
    impl Ascii {
        /// 从`bytes`构建一个`Ascii`值，不检查`bytes`是否是有效的ASCII文本。
        ///
        /// 这个函数直接返回一个`Ascii`，而不是像`from_bytes`一样返回一个
        /// `Result<Ascii, NotAsciiError>`。
        ///
        /// # 安全性
        ///
        /// 调用者必须确保`bytes`只包含ASCII字符：每个字节都不大于0x7f。
        /// 否则，最后的结果是未定义的。
        pub unsafe fn from_bytes_unchecked(bytes: Vec<u8>) -> Ascii {
            Ascii(bytes)
        }
    }
\end{minted}

如果调用\texttt{Ascii::from\_bytes\_unchecked}的代码总是知道vector中只包含有效的ASCII字符，那么\texttt{Ascii::from\_bytes}里的检查就只是在浪费时间，并且调用者还必须处理永远不会出现的\texttt{Err}结果。\texttt{Ascii::from\_bytes}可以简化这种情况下的调用和错误处理。

但之前我们曾经强调过\texttt{Ascii}的public构造器和方法保证\texttt{Ascii}的值是有效的的重要性。\texttt{from\_bytes\_unchecked}是不是没有遵守这个规则？

不完全是：\texttt{from\_bytes\_unchecked}把它的责任通过它的合约交给了调用者。这个合约的存在正是它应该被标记为\texttt{unsafe}的原因：虽然这个函数本身没有进行unsafe的操作，但它的调用者必须遵守一些Rust不能强制的规则才能避免未定义行为。

你真的能通过打破\texttt{Ascii::from\_bytes\_unchecked}的合约来导致未定义行为吗？是的。你可以像下面这样构造一个无效的\texttt{String}：
\begin{minted}{Rust}
    // 想象这个vector是一些我们认为会产生ASCII文本的操作的结果，
    // 但这个操作出错了。
    let bytes = vec![0xf7, 0xbf, 0xbf, 0xbf];
    let ascii = unsafe {
        // 当`bytes`含有非ASCII值时这个unsafe的合约就被打破了
        Ascii::from_bytes_unchecked(bytes)
    };

    let bogus: String = ascii.into();

    // `bogus` 现在包含无效的UTF-8。
    // 解析它的第一个字符会产生一个无效的Unicode码点的`char`，
    // 这是未定义行为，因此Rust不知道这个断言的行为会是什么样的。
    assert_eq!(bogus.chars().next().unwrap() as u32, 0x1fffff);
\end{minted}

在特定版本的Rust和特定的平台上，这个断言会输出下面的错误信息并失败：
\begin{minted}{text}
    thread 'main' panicked at 'assertion failed: `(left == right)`
      left: `2097151`
     right: `2097151`, src/main.rs:42:5
\end{minted}

这两个数字在我们看来似乎是相等的，但这不是Rust的问题；这是之前的\texttt{unsafe}块的问题。当我们说未定义行为会导致无法预料的结果时，这就是其中一种情况。

这个例子展示了两个有关bug和unsafe代码的关键事实：
\begin{enumerate}
    \item \emph{\texttt{unsafe}块之前发生的bug可能会打破合约}。一个\texttt{unsafe}块是否会导致未定义行为可能不仅仅取决于这个块本身，还取决于提供它要操作的值的代码。你的\texttt{unsafe}代码依赖的任何东西都是和安全相关的。只有当模块的其他部分正确的维护了\texttt{Ascii}相关的内容时，基于\texttt{String::from\_utf\_unchecked}的\texttt{Ascii}到\texttt{String}的转换才是安全的。
    \item \emph{打破合约的结果可能在你离开\texttt{unsafe}块之后才会出现}。不遵守unsafe特性而导致的未定义行为通常不会在\texttt{unsafe}块本身里出现。如上面所示，构造一个bogus \texttt{String}可能不会有问题，直到程序的程序执行中才出现问题。
\end{enumerate}

本质上讲，Rsut的类型检查、借用检查和其他的静态检查都是在分析你的程序并尝试证明它不可能会出现未定义行为。当Rust成功编译你的程序时，这意味着它成功地证明了这一点。一个\texttt{unsafe}块是这个证明中的例外：等于你在告诉Rust“它没有问题，相信我”。你的声明是否正确可能依赖程序的任何会影响到\texttt{unsafe}块的部分，并且出错时产生的结果也可能出现在任何被\texttt{unsafe}块影响的地方。\texttt{unsafe}关键字也是在提醒你，你无法完全享受到它的安全检查的好处。

如果可以选择的话，你应该尽量选择使用安全的没有合约的接口。它们更容易使用，因为用户可以依赖Rust的安全检查来保证他们的代码不可能出现未定义行为。即使你的实现使用了unsafe特性，最好使用Rust的类型、生命周期和模块系统来满足它们的合约，同事只使用你自己就可以保证的，而不是把责任传递给调用者。

不幸的是，在实际编程中遇到懒得解释它们的合约的unsafe函数并不罕见。他们期望你能依靠自己的经验和知识自己推导出这些规则。

\section{unsafe块还是unsafe函数？}
你可能会想知道是使用\texttt{unsafe}块还是直接把整个函数标记为unsafe。我们推荐的方法是首先判断函数：
\begin{enumerate}
    \item 如果这个函数可能被误用，可以成功编译但可能导致未定义行为，那么你应该将它标记为unsafe。正确使用这个函数的规则就是它的合约，也正是合约的存在让它变得unsafe。
    \item 否则，这个函数是safe的：没有调用能让它产生未定义行为。它不应该被标记为\texttt{unsafe}。
\end{enumerate}

这个函数在函数体里是否使用unsafe特性并不这个重要，关键是合约的存在。之前我们展示过一个没有使用unsafe特性的unsafe函数，也展示过一个使用了unsafe特性的safe函数。

不要只因为你在函数体里使用了unsafe特性就把safe的函数标记为\texttt{unsafe}。这只会让函数更难用，并且迷惑调用者，让他以为这里有一个合约。正确的做法是使用一个\texttt{unsafe}块，即使这个块就是整个函数体。

\section{未定义行为}
在引言中，我们说过术语\emph{未定义行为}意思是“Rust假设你的代码绝对不会出现的行为”。这是一个奇怪的说法，尤其是我们通过其他语言积累的经验告诉我们这些行为\emph{确实}会偶然出现。为什么这个概念有助于规定unsafe代码的义务？

编译器是从一种编程语言到另一种语言的转换器。Rust编译器接收一个Rust程序并把它翻译成等价的机器语言程序。但两个差别大的语言，我们说它们等价到底是什么意思？

幸运的是，相比于语言学家，对程序员来说这个问题简单的多。如果两个程序执行时总是有相同的可见的行为，那么我们说这两个程序是等价的：它们进行相同的系统调用、以等价的方式和外部函数交互等等。这有点像程序的图灵测试：如果你不能分辨出你是在和原始的程序交互还是和翻译后的程序交互，那么它们就是等价的。

现在考虑下面的代码：
\begin{minted}{Rust}
    let i = 10;
    very_trustworthy(&i);
    println!("{}", i * 100);
\end{minted}

即使我们完全不知道\texttt{very\_trustworthy}的定义，我们可以看到它只接收一个\texttt{i}的共享引用，因此这个调用不可能改变\texttt{i}的值。因此传递给\texttt{println!}的值将总是\texttt{1000}，Rust可以把这段代码翻译成机器语言，就好像我们写的是：
\begin{minted}{Rust}
    very_trustworthy(&10);
    println!("{}", 1000);
\end{minted}

这个转换后的版本和原本的有相同的可见的行为，而且它可能还要更快一点。但只有在我们认同它真的和原始的版本相同的时候考虑它的性能才有意义。如果\texttt{very\_trustworthy}被定义成这样呢？
\begin{minted}{Rust}
    fn very_trustworthy(shared: &i32) {
        unsafe {
            // 把这个共享引用转换成一个可变的指针。
            // 这是未定义行为。
            let mutable = shared as *const i32 as *mut i32;
            *mutable = 20;
        }
    }
\end{minted}

这段代码打破了共享引用的规则：它把\texttt{i}的值改成了\texttt{20}，但\texttt{i}是以共享的方式借用的。因此，现在对这个函数的调用者进行转换会产生非常明显的效果：如果Rust转换了这段代码，程序会打印出\texttt{1000}；如果它保留了这段代码并使用\texttt{i}的新值，它会打印出\texttt{2000}。在\texttt{very\_trustworthy}中打破共享引用的规则意味着共享引用的行为并不会如调用者所预期。

这类问题出现在几乎每种Rust会尝试进行的转换中。包括把一个函数内联到调用者中、当调用结束后控制流返回到调用处，等等。但是我们以一个打破了这种假设的的例子来开始这一章。

对Rust（或其他任何语言）来说基本不可能判断对程序的转换是否能保持它的含义，除非它可以信任语言的基础特性的行为和预期一样。它们是否会进行这种转换不仅依赖于眼下的代码，还可能依赖潜在的很远之外的代码。为了对你的代码做一点改动，Rust必须假设程序的其他部分的行为都是正常的。

然后这里是Rust对行为正确程序的规则：
\begin{enumerate}
    \item 程序绝对不能读取未初始化的内存。
    \item 程序绝对不能创建无效的基础值：
    \begin{enumerate}
        \item 引用、box或函数指针为\texttt{null}
        \item 既不是\texttt{0}也不是\texttt{1}的\texttt{bool}值
        \item 判断值无效的\texttt{enum}
        \item 无效的\texttt{char}值，非Unicode码点
        \item 内容不是有效的UTF-8的\texttt{str}值
        \item 虚表或者切片长度无效的胖指针
        \item \texttt{!}类型的任何值
    \end{enumerate}
    \item \autoref{ch05}中介绍的引用的规则必须要遵守。不能有引用的生命周期比引用的对象更长；共享的访问是只读访问，可变的访问是独占的访问。
    \item 程序绝对不能解引用空的、错误对齐的、或悬垂的指针。
    \item 程序绝对不能用一个指针去访问超出这个指针关联的对象的内存范围之外的位置。我们将在\nameref{DerefRawP}中详细解释这个规则。
    \item 程序必须没有数据竞争。数据竞争发生在两个线程在未同步的情况下访问相同的内存位置，并且其中至少有一个访问是写入访问。
    \item 程序绝对不能在一个其他语言通过外部函数接口所进行的调用中进行栈展开，正如在\nameref{unwind}中解释的一样。
    \item 程序必须遵守标准库函数的合约。
\end{enumerate}

由于我们还没有Rust的\texttt{unsafe}语义的完整模型，这个列表可能会随着时间的推移而改变，但这些内容很可能仍然是禁止的。

任何违反这些规则的行为都可能构成未定义行为，还会阻止Rust优化你的程序并把它们转换成机器语言。如果你打破了最后一个规则把无效的UTF-8传递给\texttt{String::from\_utf8\_unchecked}，那么之后可能2097151不等于2097151。

不使用unsafe特性的Rust代码只要能编译就能被保证遵守上述所有规则（假设编译器没有bug，我们正在逐渐靠近这个目标，但曲线和渐近线永远不会相交）。只有当你使用unsafe特性时，这些规则才会变成你自己的责任。

在C和C++中，即使你的程序没有报错成功通过了编译也意义不大；正如我们在这本书的引言中解释的，即使是用那些保持高标准代码的广受欢迎的库编写的最好的C和C++程序在实践中也会出现未定义行为。

\section{unsafe trait}\label{UnsafeTrait}
\emph{\texttt{unsafe} trait}是一种特殊的trait，它们有一个Rust无法检查或者强制实现必须遵守的规则，实现必须遵守这些规则才能避免未定义行为。为了实现一个unsafe trait，你必须将实现标记为unsafe的。理解trait的合约并确保你的实现满足合约是你的责任。

一个用unsafe trait来约束类型变量的函数通常自身也会使用unsafe特性，并且它们只依赖这些unsafe trait的合约来满足自己的合约。一个错误的trait实现可能会导致这样的函数出现未定义行为。

\texttt{std::marker::Send}和\texttt{std::marker::Sync}是unsafe trait的典型例子。这些trait并没有定义任何方法，因此可以很容易地为任何类型实现它们。但它们确实有合约：\texttt{Send}要求实现者可以安全地移动到另一个线程中，\texttt{Sync}要求实现者必须能安全地通过共享引用在线程间共享。为一个不恰当的类型实现\texttt{Send}将会使\texttt{std::sync::Mutex}不能再保证没有数据竞争。

这里有个简单的例子，Rust标准库曾经包含了一个叫\texttt{core::nonzero::Zeroable}的unsafe trait，它用来表示那些可以通过把所有字节置为0来安全地初始化的类型。举个例子，把一个\texttt{usize}置0是可以的，但把一个\texttt{\&T}置0会产生空引用，如果解引用就会崩溃。对于那些实现了\texttt{Zeroable}的类型，有一些可行的优化：你可以使用\texttt{std::ptr::write\_bytes}（\texttt{memset}在Rust中的等价函数）或者一个分配置0内存页的系统调用来快速地初始化它们的数组。（\texttt{Zeroable}是unstable的，并且在Rust 1.26中被移到只在\texttt{num} crate中内部使用，但它是一个好的、简单的、真实的例子。）

\texttt{Zeroable}是一个类型标记trait，没有方法或者关联类型：
\begin{minted}{Rust}
    pub unsafe trait Zeroable {}
\end{minted}

为恰当的类型实现这个trait非常的直观：
\begin{minted}{Rust}
    unsafe impl Zeroable for u8 {}
    unsafe impl Zeroable for i32 {}
    unsafe impl Zeroable for usize {}
    // 其他的整数类型同理
\end{minted}

有了这些定义，我们可以编写一个函数，它可以快速地分配一个给定长度的\texttt{Zeroable}类型的vector：
\begin{minted}{Rust}
    use core::nonzero::Zeroable;

    fn zeroed_vector<T>(len: usize) -> Vec<T>
        where T: Zeroable
    {
        let mut vec = Vec::with_capacity(len);
        unsafe {
            std::ptr::write_bytes(vec.as_mut_ptr(), 0, len);
            vec.set_len(len);
        }
        vec
    }
\end{minted}

这个函数首先用给定的容量创建一个空的\texttt{Vec}，然后调用\texttt{write\_bytes}用0来填充未初始化的缓冲区。（\texttt{write\_bytes}函数把\texttt{len}看做\texttt{T}类型元素的数量，而不是字节的数量，因此这个调用确实填充了整个缓冲区。）vector的\texttt{set\_len}方法只修改它的长度，不对缓冲区进行任何操作；这是unsafe的，因为你必须保证新的缓冲区空间内都包含正确初始化的\texttt{T}类型的值。但这正是\texttt{T: Zeroable}约束的：一个0字节的块代表一个有效的\texttt{T}值。我们对\texttt{set\_len}的使用是安全的。

这里，我们来使用它：
\begin{minted}{Rust}
    let v: Vec<usize> = zeroed_vector(100_000);
    assert!(v.iter().all(|&u| u == 0));
\end{minted}

显然\texttt{Zeroable}必须是一个unsafe的trait，因为一个不遵守合约的实现可能导致未定义行为：
\begin{minted}{Rust}
    struct HoldsRef<'a>(&'a mut i32);

    unsafe impl<'a> Zeroable for HoldsRef<'a> { }

    let mut v: Vec<HoldsRef> = zeroed_vector(1);
    *v[0].0 = 1;    // 崩溃：解引用空指针
\end{minted}

Rust不知道\texttt{Zeroable}表示什么，所以它不能分辨出哪些类型的实现是不恰当的。和其他的unsafe特性一样，理解并遵守unsafe trait的合约是你的责任。

注意unsafe代码绝对不能依赖正确实现的普通的safe trait。例如，假设有一个\texttt{std::hash::Hasher} trait的实现简单地返回一个随机的哈希值，这个值和被哈希的值没有一点关系。这个trait要求同样的值两次被哈希时必须产生相同的哈希值，但这个现实并不满足这个要求；它很显然是错误的。但因为\texttt{Hasher}并不是unsafe的trait，unsafe代码在使用这个哈稀器的时候不应该出现未定义行为。\texttt{std::collections::HashMap}类型是被精心编写的，它遵守所有用到的unsafe特性的合约，不管哈稀器的行为是什么样的。具体的来说，即使哈希表不能正确地工作：查找可能失败，表项可能随机出现或者消，整个表也不会出现未定义行为。

\section{原始指针}\label{rawp}
Rust中\emph{原始指针}指的是没有约束的指针。你可以使用原始指针来组织Rust的普通指针类型无法做到的数据结构，例如双向链表或者任意的图对象。但因为原始指针太过灵活，Rust无法分辨出你是否正在安全地使用它们，因此你只能在\texttt{unsafe}块中解引用它们。

原始指针基本等价于C或C++中的指针，因此在和这些语言编写的代码交互时原始指针非常有用。

有两种原始指针：
\begin{enumerate}
    \item \texttt{*mut T}是可以修改引用对象的指针。
    \item \texttt{*const T}是只能读取引用对象的指针。
\end{enumerate}
（没有\texttt{*T}类型，你必须指定\texttt{const}或者\texttt{mut}。）

你可以通过转换引用来创建原始指针，并使用\texttt{*}操作符来解引用它：
\begin{minted}{Rust}
    let mut x = 10;
    let ptr_x = &mut x as *mut i32;

    let y = Box::new(20);
    let ptr_y = &*y as *const i32;

    unsafe {
        *ptr_x += *ptr_y;
    }
    assert_eq!(x, 30);
\end{minted}

和box指针以及引用不同，原始指针可以为null，类似C中的\texttt{NULL}和C++中的\texttt{nullptr}：
\begin{minted}{Rust}
    fn option_to_raw<T>(opt: Option<&T>) -> *const T {
        match opt {
            None => std::ptr::null(),
            Some(r) => r as *const T
        }
    }

    assert!(!option_to_raw(Some(&("pea", "pod"))).is_null());
    assert_eq!(option_to_raw::<i32>(None), std::ptr::null());
\end{minted}

这个例子中没有\texttt{unsafe}块：创建、传递、比较原始指针都是safe的。只有解引用原始指针才是unsafe的。

unsized类型的原始指针是胖指针，就像相应的引用或\texttt{Box}指针一样。一个\texttt{*const [u8]}的指针除了地址之外还包括长度，一个trait对象的原始指针例如\texttt{*mut dyn std::io::Write}指针还附带一个虚表。

尽管Rust在很多场景可以隐式解引用safe的指针类型，但原始指针的解引用必须是显式的：
\begin{enumerate}
    \item \texttt{.}运算符不会隐式解引用原始指针，你必须用\texttt{(*raw).field}或者\texttt{(*raw).method(...)}。
    \item 原始指针并没有实现\texttt{Deref}，因此强制解引用并不适用于它们。
    \item \texttt{==}和\texttt{<}之类的运算符以地址比较原始指针：只有两个原始指针指向同一个内存位置它们才是相等的。类似，哈希一个原始指针会对它指向的地址进行哈希，而不是对它指向的对象的值进行哈希。
    \item 格式化trait例如\texttt{std::fmt::Dispaly}会自动解引用，但无法处理原始指针。例外的是\texttt{std::fmt::Debug}和\texttt{std::fmt::Pointer}，它们会以16进制地址的形式显示原始指针，不会解引用它们。
\end{enumerate}

和C/C++中的\texttt{+}运算符不同，Rust的\texttt{+}运算符不能用于原始指针，但你可以使用原始指针的\texttt{offset}、\texttt{wrapping\_offset}或者更方便的\texttt{add}、\texttt{sub}、\texttt{wrapping\_add}、\texttt{wrapping\_sub}方法对它们进行算数操作。\texttt{offset\_from}方法可以给出两个指针之间的距离，不过我们必须确保起点和终点在相同的内存区域（例如在同一个\texttt{Vec}）里：
\begin{minted}{Rust}
    let trucks = vec!["grabage truck", "dump truck", "moonstruck"];
    let first: *const &str = &trucks[0];
    let last: *const &str = &trucks[2];
    assert_eq!(unsafe { last.offset_from(first) }, 2);
    assert_eq!(unsafe { first.offset_from(last) }, -2);
\end{minted}

\texttt{first}和\texttt{last}不需要隐式转换，只要指明类型就够了。Rust隐式地把引用强制转换为原始指针（当然反过来不行）。

\texttt{as}运算符允许几乎把任何引用转换成原始指针或者转换两个原始指针类型。然而，你必须把一个复杂的转换拆分成一系列简单的转换。例如：
\begin{minted}{Rust}
    &vec![42_u8] as *const String;  // 错误：无效转换
    &vec![42_u8] as *const Vec<u8> as *const String;    // 允许
\end{minted}

注意\texttt{as}不能把原始指针转换为引用。这样的转换是unsafe的，而\texttt{as}应该保证是safe的操作。要想做到这一点，你必须解引用原始指针（在一个\texttt{unsafe}块中）然后借用得到的值的引用。

这么做的时候一定要小心：这种方式产生的引用将会有无限的生命周期：它的生存时间没有任何限制，因为原始指针并没有给Rust提供推断这一点的信息。在后面的\nameref{SafeInter}一节中，我们将展示几个例子来演示如何正确地约束生命周期。

很多类型都有\texttt{as\_ptr}和\texttt{as\_mut\_ptr}方法可以返回它们的内容的原始指针。例如，数组的切片和字符串会返回它们的第一个元素的指针，一些迭代器会返回它们要产生的下一个元素的指针。拥有所有权的指针类型例如\texttt{Box}、\texttt{Rc}和\texttt{Arc}有\texttt{into\_raw}和\texttt{from\_raw}函数可以转换成或转换自原始指针。其中一些方法的合约有一些令人惊讶的要求，因此在使用之前要仔细阅读它们的文档。

你也可以把整数转换成原始指针，尽管你唯一可以信任的整数是从之前的指针得到整数。\nameref{RefWithFlag}以这种方式使用了原始指针。

和引用不同，原始指针既没有实现\texttt{Send}也没有实现\texttt{Sync}。因此，任何包含原始指针的类型默认都没有实现这两个trait。在线程间发送或者共享原始指针本质上并没有什么不安全的，毕竟，不管它们去了哪，在解引用它们的时候仍然需要一个\texttt{unsafe}块。但考虑到原始指针通常扮演的角色，语言的设计者认为默认是这样会更有帮助。我们已经在\nameref{UnsafeTrait}中讨论过如何自己实现\texttt{Send}和\texttt{Sync}了。

\subsection{安全地解引用原始指针}\label{DerefRawP}
这里有一些安全使用原始指针的基本规则：
\begin{enumerate}
    \item 解引用空指针或悬垂指针是未定义行为，指向未初始化内存或超出作用域的值的指针也是如此。
    \item 解引用没有按照类型正确对齐的指针是未定义行为。
    \item 你可以从解引用原始指针获得的值借用引用，不过只有当这么做满足\nameref{ch05}中介绍的引用安全性规则时才可以：引用不能超出被引用对象的生命周期、共享的访问是只读的访问、可变的访问是独占的访问。（这个规则很容易在无意中被违反，因为原始指针通常被用来创建非标准共享或所有权的数据结构。）
    \item 只有当一个原始指针指向的对象是正确的该类型的值时你才能使用它指向的对象。例如，你必须确保解引用一个\texttt{*const char}返回一个正确的Unicode码点。
    \item 在使用原始指针的\texttt{offset}和\texttt{wrapping\_offset}方法时你必须确保最后指向的位置还在一开始指向的那个对象的值或者内存块里。\\ 如果你先把一个指针转换成整数，然后进行任何的算术运算，再把它转换回指针，那么结果必须是\texttt{offset}的规则允许你产生的指针。
    \item 如果你对原始指针指向的对象赋值，你必须保证不违反其中任何一个类型的不变量。例如，如果你有一个指向一个\texttt{String}的字节的\texttt{*mut u8}指针，你对这个\texttt{u8}赋的值必须保证\texttt{String}持有的仍是有效的UTF-8。
\end{enumerate}

除了借用规则之外，这些都是在C和C++中使用指针时必须要遵守的基本规则。

不能违背类型的不变量的原因应该很清楚。很多Rust的标准类型在实现里都使用了unsafe代码，但仍然提供了safe的接口。它们假设Rust的安全检查、模块系统和可见性规则都没有被违反。使用原始指针来绕开这些保护措施可能会导致未定义行为。

完整又精确的原始指针的合约很难简单地说清楚，也可能会随着语言的改进发生改变。但这里列出的原则应该能保证代码是安全的。

\subsection{示例：\texttt{RefWithFlag}}\label{RefWithFlag}
