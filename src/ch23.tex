\chapter{外部函数}\label{ch23}
\emph{Cyberspace. Unthinkable complexity. Lines of lightranged in the non-space of the mind, clusters andconstellations of data. Like city lights, receding . . .}

\begin{flushright}
    ——William Gibson, \emph{Neuromancer}
\end{flushright}

不幸的是，不是世界上每个程序都是用Rust编写的。我们可能想在我们的Rust程序中使用很多用其他语言实现的优秀的库和接口。Rust的\emph{外部语言接口（foreign function interface(FFI)）}让Rust代码能调用C编写的函数，和一部分C++编写的函数。因为大多数操作系统提供C接口，Rust的外部函数接口允许直接访问任何类型的底层设施。

在本章中，我们将编写一个链接到\texttt{libgit2}的程序，它是一个用于Git版本控制系统的C库。首先，我们将展示怎么直接在Rust中使用C函数，就使用我们上一章中介绍的unsafe特性。然后，我们将展示如何构建\texttt{liggit2}的safe接口，借助开源的\texttt{git2-rs} crate的灵感，这个crate正好实现了这一点。

我们将假设你熟悉C语言和编译链接C程序的机制。处理C++也相差不多。我们还假设你熟悉Git版本控制系统。

确实有Rust crate用于和很多其他语言例如Python、JavaScript、Lua和Java交互。我们没有足够的篇幅来介绍它们，但所有这些接口最终都是使用C外部函数接口实现的，因此无论你想和什么语言交互，这一章都能给你一个开头。

\section{寻找公共的数据表示}\label{repr}
Rust和C的公共基础是机器语言，因此为了预测Rust的值在C代码中看起来是什么样的，或者反过来，你需要考虑它们的机器级表示。在整本书中，我们一直着重展示一个值在内存中的实际表示，因此你可能已经注意到了C和Rust的数据世界有很多共通之处：例如一个Rust的\texttt{usize}和C的\texttt{size\_t}是相同的，两门语言中的结构体也基本相同。为了建立起Rust和C中相应类型的关系，我们将从基本类型开始，并逐渐扩展到更复杂的类型。

鉴于C主要用作系统编程，C中类型的表示总是令人惊讶的宽松：例如一个\texttt{int}通常是32位，但可能会更长，或者短到16位；一个C的\texttt{char}可能是有符号的也可能是无符号的。为了应对这种可变性，Rust的\texttt{std::os::raw}模块定义了一些Rust的类型，这些类型保证和相应的C类型有完全相同的表示（\autoref{t23-1}）。其中包括基本的整数和字符类型。

\begin{table}[htbp]
    \centering
    \caption{\texttt{std::os::raw}中的Rust类型}
    \label{t23-1}
    \begin{tabular}{ll}
        \textbf{C类型}  &   \textbf{相应的\texttt{std::os::raw}类型}    \\
        \hline
        \texttt{short}          &   \texttt{c\_short}   \\
        \rowcolor{tablecolor}
        \texttt{int}            &   \texttt{c\_int}     \\
        \texttt{long}           &   \texttt{c\_long}    \\
        \rowcolor{tablecolor}
        \texttt{long long}      &   \texttt{c\_longlong}    \\
        \texttt{unsigned short} &   \texttt{c\_ushort}  \\
        \rowcolor{tablecolor}
        \texttt{unsigned, unsigned int} &   \texttt{c\_uint}    \\
        \texttt{unsigned long}  &   \texttt{c\_ulong}   \\
        \rowcolor{tablecolor}
        \texttt{unsigned long long}     &   \texttt{c\_ulonglong}   \\
        \texttt{char}           &   \texttt{c\_char}    \\
        \rowcolor{tablecolor}
        \texttt{signed char}    &   \texttt{c\_schar}   \\
        \texttt{unsigned char}  &   \texttt{c\_uchar}   \\
        \rowcolor{tablecolor}
        \texttt{float}           &   \texttt{c\_float}    \\
        \texttt{double}         &   \texttt{c\_double}  \\
        \rowcolor{tablecolor}
        \texttt{void *, const void *}   &   \texttt{*mut c\_void, *const c\_void}   \\
    \end{tabular}
\end{table}

有关\autoref{t23-1}的注意事项：
\begin{enumerate}
    \item 除了\texttt{c\_void}之外，这里所有的Rust类型都是某些基本Rust类型的别名：例如\texttt{c\_char}是\texttt{i8}或者\texttt{u8}。
    \item Rust的\texttt{bool}等价于C或C++的\texttt{bool}。
    \item Rust的32位\texttt{char}类型并不等同于\texttt{wchar\_t}，后者的宽度和编码取决于具体实现。C的\texttt{char32\_t}倒是更接近一点，但它的编码仍然并不保证是Unicode。
    \item Rust的基础\texttt{usize}和\texttt{isize}类型和C的\texttt{size\_t}和\texttt{ptrdiff\_t}有相同的表示。
    \item C/C++指针和C++的引用对应Rust的原始指针类型\texttt{*mut T}和\texttt{*const T}。
    \item 从技术上讲，C标准允许实现使用一些Rust中没有相应类型的表示：36位整数、用符号+数字来表示有符号值等等。在实践中，在Rust被移植到的每个平台上，每个基本的C整数类型在Rust中都有对应的类型。
\end{enumerate}

为了定义兼容C结构体的Rust结构体类型，你可以使用\texttt{\#[repr(C)]}属性。在结构体的定义上面放上\texttt{\#[repr(C)]}可以要求Rust按照C编译器的方式放置结构体中的字段。例如，\texttt{libgit2}的\emph{git2/errors.h}头文件定义了下面的C结构体来提供一个错误的详情：
\begin{minted}{C}
    typedef struct {
        char *message;
        int klass;
    } git_error;
\end{minted}

你可以按照下面这样定义一个内存表示完全相同的Rust类型：
\begin{minted}{Rust}
    use std::os::raw::{c_char, c_int};

    #[repr(C)]
    pub struct git_error {
        pub message: *const c_char,
        pub klass: c_int
    }
\end{minted}

\texttt{\#[repr(C)]}属性只影响struct自身的布局，不会影响单个字段的表示，因此为了和C struct匹配，每一个字段也都要使用C风格的类型：例如用\texttt{*const c\_char}替换\texttt{char *}，用\texttt{c\_int}替换\texttt{int}。

在这个特定的例子中，\texttt{\#[repr(C)]}属性可能并不会改变\texttt{git\_error}的布局。因为实际上没有那么多放置一个指针和一个整数的方法。但C和C++都保证一个结构体的成员按照声明的顺序依次在内存中排布，而Rust会按照总结构体大小最小的方式来组织字段，并且0大小的类型不占用空间。\texttt{\#[repr(C)]}属性告诉Rust按照C的规则来布局。

你也可以使用\texttt{\#[repr(C)]}来控制C风格的enum的表示：
\begin{minted}{Rust}
    #[repr(C)]
    #[allow(non_camel_case_types)]
    enum git_error_code {
        GIT_OK          = 0,
        GIT_ERROR       = -1,
        GIT_ENOTFOUND   = -3,
        GIT_EEXISTS     = -4,
        ...
    }
\end{minted}

通常情况下，Rust在选择如何表示enum时会使用各种技巧。例如，我们提到过Rust在一个单字中存储\texttt{Option<\&T>}（如果\texttt{T}是sized）。如果没有\texttt{\#[repr(C)]}，Rust会使用单个字节来表示\texttt{git\_error\_code} enum；有了\texttt{\#[repr(C)]}之后，Rust会和C一样用一个C \texttt{int}一样大的值来存储。

你可以要求Rust使用和某些整数相同的表示来存储enum。上面的定义如果以\texttt{\#[repr(i16)]}开头，将会得到一个和下面C++ enum相同的16位的表示：
\begin{minted}{C++}
    #include <stdint.h>

    enum git_error_code: int16_t {
        GIT_OK          = 0,
        GIT_ERROR       = -1,
        GIT_ENOTFOUND   = -3,
        GIT_EEXISTS     = -4,
        ...
    };
\end{minted}

正如之前提到的，\texttt{\#[repr(C)]}还可以用于union。\texttt{\#[repr(C)]} union的字段总是从union的内存的第一个位（0偏移处）开始。

假设你有一个C struct使用一个union来存储一些数据，再用一个tag值来指示应该使用union的哪个值，类似于Rust的enum一样：
\begin{minted}{C}
    enum tag {
        FLOAT = 0,
        INT   = 1,
    };

    union number {
        float f;
        short i;
    };

    struct tagged_number {
        tag t;
        number n;
    };
\end{minted}

Rust可以通过对enum、struct和union类型都应用\texttt{\#[repr(C)]}来实现一个这样的结构体，然后使用\texttt{match}语句基于tag来选择一个struct中的union的字段：
\begin{minted}{Rust}
    #[repr(C)]
    enum Tag {
        Float = 0,m
        Int   = 1
    }

    #[repr(C)]
    union FloatOrInt {
        f: f32,
        i: i32,
    }

    #[repr(C)]
    struct Value {
        tag: Tag,
        union: FloatOrInt
    }

    fn is_zero(v: Value) -> bool {
        use self::Tag::*;
        unsafe {
            match v {
                Value { tag: Int, union: FloatOrInt { i: 0 } } => true,
                Value { tag: Float, union: FloatOrInt { f: num } } => (num == 0.0),
                _ => false
            }
        }
    }
\end{minted}

使用这种技术，即使是复杂的结构体也可以很容易地跨FFI边界使用。

在Rust和C之间传递字符串要稍微更难一点。C使用一个空结尾的字符数组的指针来表示字符串。另一边Rust显式地存储字符串的长度，要么是\texttt{String}的一个字段，要么是一个胖引用\texttt{\&str}的第二个字。Rust的字符串不是空字符结尾的；事实上，它们的内容里可能包含空字符，这些空字符和其他字符一样，没有区别。

这意味着你不能借用一个Rust字符串来当做C字符串：如果你传给C代码一个Rust字符串的指针，它可能错误地把内容中一个空字符当做字符串的结尾，或者越界去查找一个不存在的结尾空字符。从另一个方向考虑，你也许可以借用一个C字符串作为一个Rust的\texttt{\&str}，只要它的内容是有效的UTF-8。

这种情况强迫Rust必须把C的字符串看做和\texttt{String}、\texttt{\&str}完全不同的类型。在\texttt{std::ffi}模块中，\texttt{CString}和\\
\texttt{CStr}类型表示拥有所有权的和借用的空字符结尾的字节数组。和\texttt{String}、\texttt{str}比起来，\texttt{CString}和\texttt{CStr}的方法非常有限，基本只有构建自身和转换成其他类型的方法。我们将在下一节中用实例展示这些类型。

\section{声明外部函数和变量}
用\texttt{extern}块来声明其他库中定义的函数和变量，最终的Rust编译出的可执行文件会链接到这些库。例如，在大多数平台上，每个Rust程序都会链接到标准的C库，因此我们可以像这样告诉Rust C库里的\texttt{strlen}函数：
\begin{minted}{Rust}
    use std::os::raw::c_char;

    extern {
        fn strlen(s: *const c_char) -> usize;
    }
\end{minted}

这样就告诉了Rust这个函数的名字和类型，定义将会在之后进行链接。

Rust假设在\texttt{extern}块中声明的函数使用C语言的惯例来传递参数和接受返回值。它们被定义为\texttt{unsafe}函数。对\texttt{strlen}来说，这是正确的选择：它实际上是一个C函数，它的C规范要求你传入一个有效的以空字符结尾的字符串指针，而这是一个Rust无法强制的合约。（几乎任何接受原始指针作为参数的函数都必须是\texttt{unsafe}的：safe Rust可以从任何整数构造原始指针，但解引用这样的指针可能会导致未定义行为。）

有了这个\texttt{extern}块，我们可以像任何其他Rust函数一样调用\texttt{strlen}，尽管它的类型：
\begin{minted}{Rust}
    use std::ffi::CString;

    let rust_str = "I'll be back";
    let null_terminated = CString::new(rust_str).unwrap();
    unsafe {
        assert_eq!(strlen(null_terminated.as_ptr()), 12);
    }
\end{minted}

\texttt{CString::new}函数构建出一个空字符结尾的C字符串。它首先检查它的内容里是否有空字符，因为如果有空字符就不能用C字符串来表示它，如果找到了空字符就返回一个error（因此需要调用\texttt{unwrap}）。否则，它向结尾添加一个空字符并返回一个\texttt{CString}，这个\texttt{CString}持有最后的字符的所有权。

\texttt{CString::new}的开销取决于你传给它什么类型的参数。它接受任何实现了\texttt{Into<Vec<u8>>}的类型，传递一个\texttt{\&str}需要一次内存分配和拷贝，因为它到\texttt{Vec<u8>}的转换需要在堆上构建一份字符串的拷贝，这样vector才能拥有字符串的所有权。但以值传递一个\texttt{String}简单地消耗掉这个字符串并获取它的缓冲区的所有权，因此除非向缓冲区中添加一个空字符需要扩大缓冲区，否则这个转换完全不需要拷贝文本或内存分配。

\texttt{CString}解引用到\texttt{CStr}，后者的\texttt{as\_ptr}方法返回一个\texttt{*const c\_char}指向字符串的头部。这正是\texttt{strlen}期望的类型。在这个例子中，\texttt{strlen}遍历字符串，寻找\texttt{CString::new}添加的空字符，然后返回字符串的长度，即字节数。

你也可以在\texttt{extern}块中声明全局变量，POSIX系统有一个叫做\texttt{environ}的全局变量存储进程的环境变量。在C中，它被声明为：
\begin{minted}{Rust}
    extern char **environ;
\end{minted}

在Rust中，你可以写：
\begin{minted}{Rust}
    use std::ffi::CStr;
    ues std::os::raw::c_char;

    extern {
        static environ: *mut *mut c_char;
    }
\end{minted}

为了打印出环境变量的第一个元素，你可以写：
\begin{minted}{Rust}
    unsafe {
        if !environ.is_null() && !(*environ).is_null() {
            let var = CStr::from_ptr(*environ);
            println!("first environment variable: {}",
                     var.to_string_lossy())
        }
    }
\end{minted}

在确保了\texttt{environ}有第一个元素之后，代码调用了\texttt{CStr::from\_ptr}来构建一个借用它的\texttt{CStr}。\texttt{to\_string\_lossy}方法返回一个\texttt{Cow<str>}：如果C字符串包含有效的UTF-8，\texttt{Cow}会以\texttt{\&str}的形式借用它的内容，不包括结尾的空字符。否则，\texttt{to\_string\_lossy}在堆上构造一份文本的拷贝，把其中非UTF-8的字符序列替换为官方的Unicode替换字符\symbol{65533}，并构造出一个拥有它所有权的\texttt{Cow}。无论是哪种情况，结果都实现了\texttt{Display}，因此你可以使用\texttt{\{\}}格式化参数打印出它。

\section{使用库里的函数}
为了使用一个特定的库提供的函数，你可以在\texttt{extern}块上方加上\texttt{\#[link]}属性来指定Rust应该链接的库的名称。例如，这里有一个程序调用\texttt{libgit2}的初始化和结束函数，但不做任何其他事：
\begin{minted}{Rust}
    use std::os::raw::c_int;

    #[link(name = "git2")]
    extern {
        pub fn git_liggit2_init() -> c_int;
        pub fn git_liggit2_shutdown() -> c_int;
    }

    fn main() {
        unsafe {
            git_libgit2_init();
            git_libgit2_shutdown();
        }
    }
\end{minted}

\texttt{extern}和之前一样声明了外部函数。\texttt{\#[link(name = "git2")]}属性会要求当Rust创建最终的可执行文件或者共享库时，它应该链接到\texttt{git2}库。Rust使用系统的链接器来构建可执行文件：在Unix上，它会向链接器的命令行传递\texttt{-lgit2}参数；在Windows上，他会传递\texttt{git2.LIB}参数。

\texttt{\#[link]}属性在库crate中也可以工作。当你构建一个依赖其他crate的程序时，Cargo会从整个依赖图中抓取所有链接项并在最后的链接中全部加进去。

如果你想要在你自己的机器上继续这个例子，你需要自己构建\texttt{libgit2}。我们使用\href{https://libgit2.org/}{libgit2} 0.25.1版本。为了编译\texttt{libgit2}，你需要安装CMake构建工具和Python；我们使用了\href{https://cmake.org/}{CMake} 3.8.0版本和\href{https://www.python.org/}{Python} 2.7.13版本。

构建\texttt{libgit2}的完整文档可以在网站上找到，但因为非常简单所以我们将在这里展示基本的一些步骤。在Linux上，假设你已经把库的源码解压到了目录\emph{/home/jimb/libgit2-0.25.1}：
\begin{minted}{bash}
    $ cd /home/jimb/libgit2-0.25.1
    $ mkdir build
    $ cd build
    $ cmake ..
    $ cmake --build .
\end{minted}

在Linux上，这会生成一个共享库\emph{/home/jimb/libgit2-0.25.1/build/libgit2.so.0.25.1}，还有一些指向它的符号链接，包括有一个叫\emph{libgit2.so}的。在macOS上，结果与此类似，但库的名字叫\emph{libgit2.dylib}。

在Windows上也非常简单。假设你把源码解压到了目录\emph{C:\textbackslash{}Users\textbackslash{}JimB\textbackslash{}libgit2-0.25.1}。在一个Visual Studio的命令提示符中：
\begin{minted}{PowerShell}
    > cd C:\Users\JimB\libgit2-0.25.1
    > mkdir build
    > cd build
    > cmake -A x64 ..
    > cmake --build .
\end{minted}

这些命令和在Linux上用的命令几乎一样，除了在第一次运行CMake的时候必须指定64位的构建来匹配你的Rust编译器。（如果你安装了32位的Rust工具链，那么你应该省略第一条\texttt{cmake}命令的\texttt{-A x64}标记。）这会产生一个导入库\emph{git2.LIB}和一个动态链接库\emph{git2.DLL}，都在目录\emph{C:\textbackslash{}Users\textbackslash{}JimB\textbackslash{}libgit2-0.25.1\textbackslash{}build\textbackslash{}Debug}。（之后的命令都是以Unix为例，如果Windows上的命令大不相同的话会再加上Windows上的命令。）

在一个单独的目录里创建Rust程序：
\begin{minted}{bash}
    $ cd /home/jimb
    $ cargo new --bin git-toy
         Created binary (application) `git-toy` package
\end{minted}

复制我们之前展示的代码并粘贴到\emph{src/main.rs}里。当然，如果你尝试构建，Rust会不知道在哪查找你构建的\texttt{libgit2}库：
\begin{minted}{bash}
    $ cd git-toy
    $ cargo run
       Compiling git-toy v0.1.0 (/home/jimb/git-toy)
    error: linking with `cc` failed: exit code: 1
       |
       = note: /usr/bin/ld: error: cannot find -lgit2
               src/main.rs:11: error: undefined reference to 'git_libgit2_init'
               src/main.rs:12: error: undefined reference to 'git_libgit2_shutdown'
               collect2: error: ld returned 1 exit status
    
    error: aborting due to previous error
    error: could not complie `git-toy`
    To learn more, run the command again with --verbose.
\end{minted}

你可以通过编写一个\emph{构建脚本}来告诉Rust在哪搜索这个库，构建脚本是Cargo会在编译期编译并运行的Rust代码。构建脚本可以做很多事：动态生成代码，编译要被包含在crate中的C代码等等。在这个例子中，你需要做的只是向可执行文件的链接命令中添加一个库的搜索路径。当Cargo运行构建脚本时，它会解析构建脚本的输出来获取这类信息，因此构建脚本只需要把正确的信息打印到标准输出就可以了。

为了创建你自己的构建脚本，在\emph{Cargo.toml}所在的目录下添加一个叫\emph{build.rs}的文件，内容如下：
\begin{minted}{Rust}
    fn main() {
        println!(r"cargo:rustc-link-search=native=/home/jimb/libgit2-0.25.1/build");
    }
\end{minted}

这是Linux上的正确路径；在Windows上，你应该把\texttt{native=}之后的路径替换为\texttt{C:\textbackslash{}Users\textbackslash{}JimB\textbackslash{}liggit2-0.25.1\textbackslash{}build\textbackslash{}Debug}。（我们忽略了一些细节来保证这个例子的简洁；在一个真实的应用中，你应该避免在构建脚本中使用绝对路径。我们在本节结尾给出了如何正确实现这一点的文档。）

现在你基本上可以运行这个程序了。在macOS上它可能可以立即工作；但在Linux系统上你可能会看到类似这样的输出：
\begin{minted}{bash}
    $ cargo run
       Compiling git-toy v0.1.0 (/tmp/rustbook-transcript-tests/git-toy)
        Finished dev [unoptimized + debuginfo] target(s)
         Running `target/debug/git-toy`
    target/debug/git-toy: error while loading shared libraries: libgit2.so.25: cannot open shared object file:
    no such file or directory
\end{minted}

意思是说，尽管Cargo成功地把可执行文件链接到了库，但它不知道怎么在运行时找到共享库。在Windows上通过弹出一个对话框来报告这个错误。在Linux上，你必须设置\texttt{LD\_LIBRARY\_PATH}环境变量：
\begin{minted}{bash}
    $ export LD_LIBRARY_PATH=/home/jimb/libgit2-0.25.1/build:$LD_LIBRARY_PATH
    $ cargo run
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
         Running `target/debug/git-toy`
\end{minted}

在macOS上，你可能需要设置\texttt{DYLD\_LIBRARY\_PATH}。

在Windows上，你必须设置\texttt{PATH}环境变量：
\begin{minted}{PowerShell}
    > set PATH=C:\Users\JimB\libgit2-0.25.1\build\Debug;%PATH%
    > cargo run
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
         Running `target/debug/git-toy`
    >
\end{minted}

当然，在一个要部署的应用中你可能想避免只为了寻找你的库而修改环境变量。一种替代方案是把C库静态链接到你的crate里。这会把库的目标文件拷贝到crate的\emph{.rlib}文件里，和这个crate中的Rust代码生成的目标文件和元数据放在一起。然后这整个集合会参与最终的链接。

Cargo的一个惯例是提供C库访问的crate应该命名为\texttt{LIB-sys}，其中\texttt{LIB}是C库的名称。一个\texttt{-sys} crate应该只包含静态链接的库和包含\texttt{extern}块和类型定义的Rust模块。更高层的接口应该应该在依赖\texttt{-sys} crate的crate中实现。这允许多个上游的crate依赖同一个\texttt{-sys} crate，假设有一个版本的\texttt{-sys} crate可以满足每个上游的需要。

有关Cargo的构建脚本和与系统库的链接的完整文档见\href{https://doc.rust-lang.org/cargo/reference/build-scripts.html}{在线Cargo文档}。它展示了如何在构建脚本中避免绝对路径、控制编译选项、使用例如\texttt{pkg-config}的工具，等等。\texttt{git2-rs} crate也提供了模仿的好例子：它的构建脚本处理了一些很复杂的情况。

\section{一个libgit2的原始接口}


\section{一个libgit2的安全接口}\label{SafeInter}