\chapter{表达式}\label{ch06}

\emph{LISP programmers know the value of everything, but the cost of nothing}

\begin{flushright}
    ——Alan Perlis, epigram \#55
\end{flushright}

在这一章中，我们将介绍Rust的\emph{表达式}，它是构成Rust函数体和大部分Rust代码的构建块。Rust中大部分都是表达式。在这一章中，我们将探索表达式的力量以及如何克服它的局限。我们还将介绍控制流，它在Rust中完全是以表达式为基础的，最后还要介绍Rust中的基本运算符如何单独和组合工作。

还有一些从技术角度应该划入这一类的概念，例如闭包和迭代器，因为足够重要因此我们之后会用单独的章节介绍它们。现在，我们希望能用尽可能少的页数介绍尽可能多的语法。

\section{表达式语言}

Rust表面上看上去像C家族的语言，但这其实是一个误解。在C语言中，\emph{表达式}和\emph{语句}之间有很大的不同。表达式是一些像这样的代码：
\begin{minted}{C}
    5 * (fahr-32) / 9
\end{minted}
而语句则是像这样的：
\begin{minted}{C}
    for (; begin != end; ++begin) {
        if (*begin == target)
            break;
    }
\end{minted}
表达式有值，但语句没有。

Rust是一种\emph{表达式语言}。这意味着它遵循了起源于Lisp的传统，也就是表达式负责完成所有工作。

在C中，\texttt{if}和\texttt{switch}是语句。它们并不产生值，也不能被用在表达式中间。在Rust中，\texttt{if}和\texttt{match}\emph{可以}产生值。我们已经在\hyperref[ch02]{第2章}中看到过一个产生数字值的\texttt{match}表达式：
\begin{minted}{Rust}
    pixels[r * bounds.0 + c] =
        match escapes(Complex { re: point.0, im: point.1 }, 255) {
            None => 0,
            Some(count) => 255 - count as u8
        };
\end{minted}

一个\texttt{if}表达式可以用于初始化一个变量：
\begin{minted}{Rust}
    let status =
        if cpu.temperature <= MAX_TEMP {
            HttpStatus::Ok
        } else {
            HttpStatus::ServerError  // server melted
        };
\end{minted}

一个\texttt{match}表达式可以被用作函数参数或宏的参数：
\begin{minted}{Rust}
    println!("Inside the vat, you see {}.",
        match vat.contents {
            Some(brain) => brain.desc(),
            None => "nothing of interest"
        });
\end{minted}

这解释了Rust为什么没有C的三元运算符\texttt{(expr1 ? expr2 : expr3))}。在C中，它是一种类似\texttt{if}语句的表达式。在Rust中这种写法是多余的，因为\texttt{if}表达式可以同时实现这两种功能。

C中的大部分控制流工具都是语句，在Rust中则全是表达式。

\section{优先级和结合性}

\hyperref[t6-1]{表6-1}总结了Rust的表达式语法。我们将在这一章中介绍所有这些表达式。运算符按照优先级从高到低的顺序列出。（类似于大多数编程语言，Rust使用\emph{运算符优先级}来决定当表达式中含有多个运算符时的运算顺序。例如，在表达式\texttt{limit < 2 * broom.size + 1}中，\texttt{.}运算符优先级最高，因此会先访问字段。）

\begin{longtable}{p{0.25\textwidth}p{0.35\textwidth}p{0.3\textwidth}}
    \caption{表达式}
    \label{t6-1} \\
    \hline
    \textbf{表达式类型} & \textbf{示例} & \textbf{相关trait} \\
    \hline
    数组字面量      & \texttt{[1, 2, 3]}         & \\
    重复数组字面量  & \texttt{[0; 50]}           & \\
    元组            & \texttt{(6, "crullers")}  & \\
    \cline{1-2}
    组合            & \texttt{(2 + 2)}             & \\
    块              & \texttt{\{ f(); g() \}}      & \\
    控制流表达式     & \texttt{if ok \{ f() \}}     & \\
                    & \texttt{if ok \{ 1 \} else \{ 0 \}}                   & \\
                    & \texttt{if let Some(x) = f() \{ x \} else \{ 0 \}}    & \\
                    & \texttt{match x \{ None => 0, \_ => 1 \}}             & \\
                    & \texttt{for v in e \{ f(v); \}}                       & \texttt{\hyperref[iter]{std::iter::IntoIterator}} \\
                    & \texttt{while ok \{ ok = f(); \}}                     & \\
                    & \texttt{while let Some(x) = it.next() \{ f(x); \}}    & \\
                    & \texttt{loop \{ next\_event(); \}}                    & \\
                    & \texttt{break}                  & \\
                    & \texttt{continue}               & \\
                    & \texttt{return 0}               & \\
    宏调用          & \texttt{println!("ok")}         & \\
    路径            & \texttt{std::f64::consts::PI}   & \\
    \cline{1-2}
    结构体字面量     & \texttt{Point \{x: 0, y: 0\}}     & \\
    \cline{1-2}
    元组字段访问    & \texttt{pair.0}   & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    结构体字段访问  & \texttt{point.x}  & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    方法调用       & \texttt{point.translate(50, 50)} & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    函数调用       & \texttt{stdin()}   & \texttt{\hyperref[fn]{Fn(Arg0, ...) -> T}, \hyperref[fn]{FnMut(Arg0, ...) -> T}, \hyperref[fn]{FnOnce(Arg0, ...) -> T}} \\
    索引            & \texttt{arr[0]}   & \texttt{\hyperref[index]{Index}, \hyperref[index]{IndexMut}, \hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    \cline{1-2}
    错误检查        & \texttt{create\_dir("tmp")?}   & \\
    \cline{1-2}
    逻辑/位 NOT     & \texttt{!ok}  & \texttt{\hyperref[unop]{Not}} \\
    负             & \texttt{-num}  & \texttt{\hyperref[unop]{Neg}} \\
    解引用          & \texttt{*ptr} & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    借用            & \texttt{\&val}    & \\
    \cline{1-2}
    类型转换    & \texttt{x as u32} & \\
    \cline{1-2}
    乘法        & \texttt{n * 2}    & \texttt{\hyperref[biop]{Mul}} \\
    除法        & \texttt{n / 2}    & \texttt{\hyperref[biop]{Div}} \\
    余数（取模） & \texttt{n \% 2}   & \texttt{\hyperref[biop]{Rem}} \\
    \hline
    加法        & \texttt{n + 1}    & \texttt{\hyperref[biop]{Add}} \\
    减法        & \texttt{n - 1}    & \texttt{\hyperref[biop]{Sub}} \\
    \hline
    左移        & \texttt{n << 1}   & \texttt{\hyperref[biop]{Shl}} \\
    右移        & \texttt{n >> 1}   & \texttt{\hyperref[biop]{Shr}} \\
    \hline
    位与        & \texttt{n \& 1}   & \texttt{\hyperref[biop]{BitAnd}} \\
    \hline
    位异或      & \texttt{n \^{} 1} & \texttt{\hyperref[biop]{BitXor}} \\
    \hline
    位或        & \texttt{n | 1}    & \texttt{\hyperref[biop]{BitOr}}  \\
    \hline
    小于        & \texttt{n < 1}    & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    小于等于    & \texttt{n <= 1}   & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    大于        & \texttt{n > 1}    & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    大于等于    & \texttt{n >= 1}   & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    等于        & \texttt{n == 1}   & \texttt{\hyperref[equal]{std::cmp::PartialEq}} \\
    不等于      & \texttt{n != 1}   & \texttt{\hyperref[equal]{std::cmp::PartialEq}} \\   
    \hline
    逻辑与      & \texttt{x.ok \&\& y.ok}       & \\
    \cline{1-2}
    逻辑或      & \texttt{x.ok || backup.ok}    & \\
    \cline{1-2}
    左闭右开区间 & \texttt{start .. stop}   & \\
    左闭右闭区间 & \texttt{start ..= stop}  & \\
    \cline{1-2}
    赋值        & \texttt{x = val}  & \\
    复合赋值    & \texttt{x *= 1}   & \texttt{\hyperref[assign]{MulAssign}} \\
                & \texttt{x /= 1}   & \texttt{\hyperref[assign]{DivAssign}} \\
                & \texttt{x \%= 1}  & \texttt{\hyperref[assign]{RemAssign}} \\
                & \texttt{x += 1}   & \texttt{\hyperref[assign]{AddAssign}} \\
                & \texttt{x -= 1}   & \texttt{\hyperref[assign]{SubAssign}} \\
                & \texttt{x <<= 1}  & \texttt{\hyperref[assign]{ShlAssign}} \\
                & \texttt{x >>= 1}  & \texttt{\hyperref[assign]{ShrAssign}} \\
                & \texttt{x \&= 1}  & \texttt{\hyperref[assign]{BitAndAssign}} \\
                & \texttt{x \^{}= 1}& \texttt{\hyperref[assign]{BitXorAssign}} \\
                & \texttt{x |= 1}   & \texttt{\hyperref[assign]{BitOrAssign}} \\
    \cline{1-2}
    闭包        & \texttt{|x, y| x + y} & \\
\end{longtable}

所有可以链式使用的运算符都是左结合的。也就是说，一条运算链例如\texttt{a - b - c}被组合为\texttt{(a - b) - c}，而不是\texttt{a - (b - c)}。这些运算符可以被任意组合：
\begin{minted}{text}
    * / % + - << >> & ^ | && || as
\end{minted}
比较运算符、赋值运算符、范围运算符\texttt{.. }和\texttt{..=}不能被链式使用。

\section{块和分号}

块是最通用的表达式。一个块产生一个值，可以被用于任何需要一个值的地方：\begin{minted}{Rust}
    let display_name = match post.author() {
        Some(author) => author.name(),
        None => {
            let network_info = post.get_network_metadata()?;
            let ip = network_info.client_address();
            ip.to_string()
        }
    };
\end{minted}
\texttt{Some(author) =>}之后的代码是简单的表达式\texttt{author.name()}，\texttt{None =>}之后的代码则是一个块表达式。对Rust来种，两种表达式没有区别。块表达式的值是它的最后一条表达式的值，也就是\texttt{ip.to\_string()}。

注意\texttt{ip.to\_string()}后面没有分号。Rust中的大部分代码行都以分号或者花括号结尾，类似于C和Java。如果一个块看起来像C代码一样在所有的表达式后边都有分号，那它的行为就和C块一样，它的值将是\texttt{()}。正如我们在\hyperref[ch02]{第2章}提到的，当你省略了块中最后一个表达式后边的分号，那么块的值将是最后一个表达式的值，而不是通常的\texttt{()}。

在一些语言中，尤其是Javascript，你可以省略分号，语言会自动为你添加上——这样除了方便一点，并没有任何区别。然而在Rust中，分号通常是有实际意义的：
\begin{minted}{Rust}
    let msg = {
        // let语句：总是需要分号
        let dandelion_control = puffball.open();

        // 表达式 + 分号：方法被调用，返回值被丢弃
        dandelion_control.release_all_seeds(launch_codes);

        // 没有分号的表达式：方法被调用，
        // 返回值被存储到 `msg`
        dandelion_control.get_status()
    };
\end{minted}

语句块可以包含声明最后还能产生一个值的能力是一个很有用的特性，而且可以很快习惯。它的一个缺陷是如果你偶然忘记了分号会导致一条错误信息：
\begin{minted}{Rust}
    ...
    if preferences.changed() {
        page.compute_size()  // oops, 缺少分号
    }
\end{minted}

如果你在C或者Java程序中犯了这种错误，编译器会简单地直接指出你少写了一个分号。然而这是Rust的报错：
\begin{minted}{text}
    error[E0308]: mismatched types
    22 |         page.compute_size()  // oops, missing semicolon
       |         ^^^^^^^^^^^^^^^^^^^- help: try adding a semicolon `;`
       |         |
       |         expected (), found tuple
       |
       = note: expected unit type `()`
                  found tuple `(u32, u32)`
\end{minted}

在缺少分号的情况下，块的值将是\texttt{page.compute\_size()}返回的值，但一个没有\texttt{else}分支的\texttt{if}语句必须总是返回\texttt{()}。幸运的是，Rust知道这种类型的错误并建议加上分号。

\section{声明}

除了表达式和分号之外，一个块中可能包含任意数量的声明。最常见的情况是\texttt{let}声明，它用来声明局部变量：
\begin{minted}{Rust}
    let name: type = expr;
\end{minted}

类型和初始值是可选的，分号是必须的。

一个\texttt{let}声明可以在不初始化的情况下声明一个变量。这有时很有用，因为有时候一个变量需要在控制流的中途初始化：
\begin{minted}{Rust}
    let name;
    if user.has_nickname() {
        name = user.nickname();
    } else {
        name = generate_unique_name();
        user.register(&name);
    }
\end{minted}

局部变量\texttt{name}有两种不同的初始化路径，但两条路径上它都只会被初始化一次，所以\texttt{name}不需要声明为\texttt{mut}。

在变量初始化之前使用它会导致错误（这和使用被移动的值的错误紧密相关，Rust希望你只在变量的值存在时使用它们！）。

你有时可能会看到代码似乎重新声明一个已经存在的变量，例如：
\begin{minted}{Rust}
    for line in file.lines() {
        let line = line?;
        ...
    }
\end{minted}

\texttt{let}声明创建了一个新的、类型不同的、第二个变量\texttt{line}。第一个\texttt{line}的类型是\texttt{Result<String, io::Error>}，第二个\texttt{line}是一个\texttt{String}。第二个声明在块的剩余部分会取代第一个。这被称为\emph{遮蔽(shadowing)}，在Rust程序中非常常见。上面的代码等价于：
\begin{minted}{Rust}
    for line_result in file.lines() {
        let line = line_result?;
        ...
    }
\end{minted}

在这本书中，我们将坚持在这种场景中使用\texttt{\_result}后缀，来保证变量的名字不同。

一个块还可以包含\emph{item declarations}。一个item是一个可以出现在全局或模块中的声明，例如\texttt{fn}、\texttt{struct}、\texttt{use}。

后面的章节将会详细介绍item。现在，\texttt{fn}足够作为一个例子了。任何块都可以包含\texttt{fn}声明：
\begin{minted}{Rust}
    use std::io;
    use std::cmp::Ordering;

    fn show_files() -> io::Result<()> {
        let mut v = vec![];
        ...
        fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
            a.timestamp.cmp(&b.timestamp)   // 首先，比较时间戳 
                .reverse()                  // 最新的文件优先
                .then(a.path.cmp(&b.path))  // 比较路径
        }

        v.sort_by(cmp_by_timestamp_then_name);
        ...
    }
\end{minted}

当一个\texttt{fn}在块内声明的时候，它的作用域是整个块，它可以在整个块内\emph{使用}。但是一个嵌套的\texttt{fn}不能访问外围作用域的局部变量和参数。例如，函数\texttt{cmp\_by\_timestamp\_then\_name}不能使用\texttt{v}。（Rust还有闭包，闭包可以使用外层作用域的变量，见\hyperref[ch14]{第14章}。）

一个块甚至可以包含整个模块。这听起来可能有些多余了：我们真的需要把语言的\emph{每一部分}嵌套在其他部分中的能力吗？——但程序员（尤其是使用宏的程序员）可以找到语言提供的每一个正交碎片的用法。

\section{if与match}

\texttt{if}表达式的形式大家都很熟悉：
\begin{minted}{Rust}
    if condition1 {
        block1
    } else if condition2 {
        block2
    } else {
        block_n
    }
\end{minted}

每一个\texttt{condition}都必须是\texttt{bool}类型的表达式，Rust不会隐式地将数字或者指针类型转换为布尔值。

和C不同的是条件表达式不需要括号，事实上如果有不必要的括号的话，\texttt{rustc}会发出警告。然而，花括号是必须的。

\texttt{else if}块，和最后的\texttt{else}都是可选的。一个没有\texttt{else}块的\texttt{if}表达式类似于一个\texttt{else}块为空的\texttt{if}表达式。

\texttt{match}表达式有些类似于C的\texttt{switch}语句，但是更加灵活。一个简单的例子如下：
\begin{minted}{Rust}
    match code {
        0 => println!("OK"),
        1 => println!("Wires Tangled"),
        2 => println!("User Asleep"),
        _ => println!("Unrecognized Error {}", code)
    }
\end{minted}
这类似于一个\texttt{switch}语句，\texttt{match}表达式的四条分支里只有一条会执行，取决于\texttt{code}的值。通配符模式\texttt{\_}可以匹配任何情况，类似于\texttt{switch}语句中的\texttt{default:}标签，不过它会覆盖之后的所有模式，它之后的模式将永远不会匹配到任何东西（出现这种情况时编译器也会警告你）。

编译器可以使用跳转表来优化这种\texttt{match}表达式，就类似于C++中的\texttt{switch}语句。当\texttt{match}的每个分支都返回常量值时还会有一个类似的优化，这种情况下，编译器会用那些值构建一个数组，然后\texttt{match}会被编译为一次数组访问，这种情况下除了边界检查之外，编译出的代码将不会有任何条件分支。

每个分支中\texttt{=>}左侧支持多种\emph{模式}，这是\texttt{match}功能强大的根源。上边的例子中，每种模式都只是一个简单的整数。我们还展示过区分\texttt{Option}的两种值的\texttt{match}表达式：
\begin{minted}{Rust}
    match params.get("name") {
        Some(name) => println!("Hello, {}!", name);
        None => println!("Greetings, stranger.");
    }
\end{minted}

这只是模式的一个小应用，一个模式可以匹配很多值。它可以解包元组，可以匹配结构体中的每个字段，可以解引用，借用一个值的一部分，等等。Rust的模式是一种专门的mini语言。我们将在\hyperref[ch10]{第10章}中介绍它们。

\texttt{match}表达式的通用形式是：
\begin{minted}{Rust}
    match value {
        pattern => expr,
        ...
    }
\end{minted}
如果\texttt{expr}是一个块的话，分支最后的逗号可以省略。

Rust会从第一个分支开始，逐个检查\texttt{value}和给定的模式是否匹配。当有一个模式匹配时，相应的\texttt{expr}将会被求值，整个\texttt{match}表达式将完成执行，不会再检查别的模式。必须至少有一个模式可以匹配，Rust会禁止没有覆盖所有可能情况的\texttt{match}表达式：
\begin{minted}{Rust}
    let score = match card.rank {
        Jack => 10,
        Queen => 10,
        Ace => 11
    };  // 错误：没有穷尽所有模式
\end{minted}

\texttt{if}表达式的所有块必须产生相同类型的值：
\begin{minted}{Rust}
    let suggested_pet = 
        if with_wings { Pet::Buzzard } else { Pet::Hyena }; // ok
    let favorite_number =
        if user.is_hobbit() { "eleventy-one" } else { 9 };  // error
    let best_sports_team = 
        if is_hockey_season() { "Predators" };  // error
\end{minted}
（最后一个例子会导致错误，因为在7月结果将是\texttt{()}。）\footnote{译者注：7月不是曲棍球赛季？}

类似的，\texttt{match}表达式的分支也必须有相同的类型：
\begin{minted}{Rust}
    let suggested_pet =
        match favorite.element {
            Fire => Pet::RedPanda,
            Air => Pet::Buffalo,
            Water => Pet::Orca,
            _ => None   // 错误：类型不一致
        }
\end{minted}

\section{类型转换}\label{cast}
