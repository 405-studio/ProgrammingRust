\chapter{表达式}\label{ch06}

\emph{LISP programmers know the value of everything, but the cost of nothing}

\begin{flushright}
    ——Alan Perlis, epigram \#55
\end{flushright}

在这一章中，我们将介绍Rust的\emph{表达式}，它是构成Rust函数体和大部分Rust代码的构建块。Rust中大部分都是表达式。在这一章中，我们将探索表达式的力量以及如何克服它的局限。我们还将介绍控制流，它在Rust中完全是以表达式为基础的，最后还要介绍Rust中的基本运算符如何单独和组合工作。

还有一些从技术角度应该划入这一类的概念，例如闭包和迭代器，因为足够重要因此我们之后会用单独的章节介绍它们。现在，我们希望能用尽可能少的页数介绍尽可能多的语法。

\section{表达式语言}

Rust表面上看上去像C家族的语言，但这其实是一个误解。在C语言中，\emph{表达式}和\emph{语句}之间有很大的不同。表达式是一些像这样的代码：
\begin{minted}{C}
    5 * (fahr-32) / 9
\end{minted}
而语句则是像这样的：
\begin{minted}{C}
    for (; begin != end; ++begin) {
        if (*begin == target)
            break;
    }
\end{minted}
表达式有值，但语句没有。

Rust是一种\emph{表达式语言}。这意味着它遵循了起源于Lisp的传统，也就是表达式负责完成所有工作。

在C中，\texttt{if}和\texttt{switch}是语句。它们并不产生值，也不能被用在表达式中间。在Rust中，\texttt{if}和\texttt{match}\emph{可以}产生值。我们已经在\hyperref[ch02]{第2章}中看到过一个产生数字值的\texttt{match}表达式：
\begin{minted}{Rust}
    pixels[r * bounds.0 + c] =
        match escapes(Complex { re: point.0, im: point.1 }, 255) {
            None => 0,
            Some(count) => 255 - count as u8
        };
\end{minted}

一个\texttt{if}表达式可以用于初始化一个变量：
\begin{minted}{Rust}
    let status =
        if cpu.temperature <= MAX_TEMP {
            HttpStatus::Ok
        } else {
            HttpStatus::ServerError  // server melted
        };
\end{minted}

一个\texttt{match}表达式可以被用作函数参数或宏的参数：
\begin{minted}{Rust}
    println!("Inside the vat, you see {}.",
        match vat.contents {
            Some(brain) => brain.desc(),
            None => "nothing of interest"
        });
\end{minted}

这解释了Rust为什么没有C的三元运算符\texttt{(expr1 ? expr2 : expr3))}。在C中，它是一种类似\texttt{if}语句的表达式。在Rust中这种写法是多余的，因为\texttt{if}表达式可以同时实现这两种功能。

C中的大部分控制流工具都是语句，在Rust中则全是表达式。

\section{优先级和结合性}

\hyperref[t6-1]{表6-1}总结了Rust的表达式语法。我们将在这一章中介绍所有这些表达式。运算符按照优先级从高到低的顺序列出。（类似于大多数编程语言，Rust使用\emph{运算符优先级}来决定当表达式中含有多个运算符时的运算顺序。例如，在表达式\texttt{limit < 2 * broom.size + 1}中，\texttt{.}运算符优先级最高，因此会先访问字段。）

\begin{longtable}{p{0.25\textwidth}p{0.35\textwidth}p{0.3\textwidth}}
    \caption{表达式}
    \label{t6-1} \\
    \hline
    \textbf{表达式类型} & \textbf{示例} & \textbf{相关trait} \\
    \hline
    数组字面量      & \texttt{[1, 2, 3]}         & \\
    重复数组字面量  & \texttt{[0; 50]}           & \\
    元组            & \texttt{(6, "crullers")}  & \\
    \cline{1-2}
    组合            & \texttt{(2 + 2)}             & \\
    块              & \texttt{\{ f(); g() \}}      & \\
    控制流表达式     & \texttt{if ok \{ f() \}}     & \\
                    & \texttt{if ok \{ 1 \} else \{ 0 \}}                   & \\
                    & \texttt{if let Some(x) = f() \{ x \} else \{ 0 \}}    & \\
                    & \texttt{match x \{ None => 0, \_ => 1 \}}             & \\
                    & \texttt{for v in e \{ f(v); \}}                       & \texttt{\hyperref[iter]{std::iter::IntoIterator}} \\
                    & \texttt{while ok \{ ok = f(); \}}                     & \\
                    & \texttt{while let Some(x) = it.next() \{ f(x); \}}    & \\
                    & \texttt{loop \{ next\_event(); \}}                    & \\
                    & \texttt{break}                  & \\
                    & \texttt{continue}               & \\
                    & \texttt{return 0}               & \\
    宏调用          & \texttt{println!("ok")}         & \\
    路径            & \texttt{std::f64::consts::PI}   & \\
    \cline{1-2}
    结构体字面量     & \texttt{Point \{x: 0, y: 0\}}     & \\
    \cline{1-2}
    元组字段访问    & \texttt{pair.0}   & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    结构体字段访问  & \texttt{point.x}  & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    方法调用       & \texttt{point.translate(50, 50)} & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    函数调用       & \texttt{stdin()}   & \texttt{\hyperref[fn]{Fn(Arg0, ...) -> T}, \hyperref[fn]{FnMut(Arg0, ...) -> T}, \hyperref[fn]{FnOnce(Arg0, ...) -> T}} \\
    索引            & \texttt{arr[0]}   & \texttt{\hyperref[index]{Index}, \hyperref[index]{IndexMut}, \hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    \cline{1-2}
    错误检查        & \texttt{create\_dir("tmp")?}   & \\
    \cline{1-2}
    逻辑/位 NOT     & \texttt{!ok}  & \texttt{\hyperref[unop]{Not}} \\
    负             & \texttt{-num}  & \texttt{\hyperref[unop]{Neg}} \\
    解引用          & \texttt{*ptr} & \texttt{\hyperref[deref]{Deref}, \hyperref[deref]{DerefMut}} \\
    借用            & \texttt{\&val}    & \\
    \cline{1-2}
    类型转换    & \texttt{x as u32} & \\
    \cline{1-2}
    乘法        & \texttt{n * 2}    & \texttt{\hyperref[biop]{Mul}} \\
    除法        & \texttt{n / 2}    & \texttt{\hyperref[biop]{Div}} \\
    余数（取模） & \texttt{n \% 2}   & \texttt{\hyperref[biop]{Rem}} \\
    \hline
    加法        & \texttt{n + 1}    & \texttt{\hyperref[biop]{Add}} \\
    减法        & \texttt{n - 1}    & \texttt{\hyperref[biop]{Sub}} \\
    \hline
    左移        & \texttt{n << 1}   & \texttt{\hyperref[biop]{Shl}} \\
    右移        & \texttt{n >> 1}   & \texttt{\hyperref[biop]{Shr}} \\
    \hline
    位与        & \texttt{n \& 1}   & \texttt{\hyperref[biop]{BitAnd}} \\
    \hline
    位异或      & \texttt{n \^{} 1} & \texttt{\hyperref[biop]{BitXor}} \\
    \hline
    位或        & \texttt{n | 1}    & \texttt{\hyperref[biop]{BitOr}}  \\
    \hline
    小于        & \texttt{n < 1}    & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    小于等于    & \texttt{n <= 1}   & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    大于        & \texttt{n > 1}    & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    大于等于    & \texttt{n >= 1}   & \texttt{\hyperref[cmp]{std::cmp::PartialOrd}} \\
    等于        & \texttt{n == 1}   & \texttt{\hyperref[equal]{std::cmp::PartialEq}} \\
    不等于      & \texttt{n != 1}   & \texttt{\hyperref[equal]{std::cmp::PartialEq}} \\   
    \hline
    逻辑与      & \texttt{x.ok \&\& y.ok}       & \\
    \cline{1-2}
    逻辑或      & \texttt{x.ok || backup.ok}    & \\
    \cline{1-2}
    左闭右开区间 & \texttt{start .. stop}   & \\
    左闭右闭区间 & \texttt{start ..= stop}  & \\
    \cline{1-2}
    赋值        & \texttt{x = val}  & \\
    复合赋值    & \texttt{x *= 1}   & \texttt{\hyperref[assign]{MulAssign}} \\
                & \texttt{x /= 1}   & \texttt{\hyperref[assign]{DivAssign}} \\
                & \texttt{x \%= 1}  & \texttt{\hyperref[assign]{RemAssign}} \\
                & \texttt{x += 1}   & \texttt{\hyperref[assign]{AddAssign}} \\
                & \texttt{x -= 1}   & \texttt{\hyperref[assign]{SubAssign}} \\
                & \texttt{x <<= 1}  & \texttt{\hyperref[assign]{ShlAssign}} \\
                & \texttt{x >>= 1}  & \texttt{\hyperref[assign]{ShrAssign}} \\
                & \texttt{x \&= 1}  & \texttt{\hyperref[assign]{BitAndAssign}} \\
                & \texttt{x \^{}= 1}& \texttt{\hyperref[assign]{BitXorAssign}} \\
                & \texttt{x |= 1}   & \texttt{\hyperref[assign]{BitOrAssign}} \\
    \cline{1-2}
    闭包        & \texttt{|x, y| x + y} & \\
\end{longtable}

所有可以链式使用的运算符都是左结合的。也就是说，一条运算链例如\texttt{a - b - c}被组合为\texttt{(a - b) - c}，而不是\texttt{a - (b - c)}。这些运算符可以被任意组合：
\begin{minted}{text}
    * / % + - << >> & ^ | && || as
\end{minted}
比较运算符、赋值运算符、范围运算符\texttt{.. }和\texttt{..=}不能被链式使用。

\section{块和分号}

块是最通用的表达式。一个块产生一个值，可以被用于任何需要一个值的地方：\begin{minted}{Rust}
    let display_name = match post.author() {
        Some(author) => author.name(),
        None => {
            let network_info = post.get_network_metadata()?;
            let ip = network_info.client_address();
            ip.to_string()
        }
    };
\end{minted}
\texttt{Some(author) =>}之后的代码是简单的表达式\texttt{author.name()}，\texttt{None =>}之后的代码则是一个块表达式。对Rust来种，两种表达式没有区别。块表达式的值是它的最后一条表达式的值，也就是\texttt{ip.to\_string()}。

注意\texttt{ip.to\_string()}后面没有分号。Rust中的大部分代码行都以分号或者花括号结尾，类似于C和Java。如果一个块看起来像C代码一样在所有的表达式后边都有分号，那它的行为就和C块一样，它的值将是\texttt{()}。正如我们在\hyperref[ch02]{第2章}提到的，当你省略了块中最后一个表达式后边的分号，那么块的值将是最后一个表达式的值，而不是通常的\texttt{()}。

在一些语言中，尤其是Javascript，你可以省略分号，语言会自动为你添加上——这样除了方便一点，并没有任何区别。然而在Rust中，分号通常是有实际意义的：
\begin{minted}{Rust}
    let msg = {
        // let语句：总是需要分号
        let dandelion_control = puffball.open();

        // 表达式 + 分号：方法被调用，返回值被丢弃
        dandelion_control.release_all_seeds(launch_codes);

        // 没有分号的表达式：方法被调用，
        // 返回值被存储到 `msg`
        dandelion_control.get_status()
    };
\end{minted}

语句块可以包含声明最后还能产生一个值的能力是一个很有用的特性，而且可以很快习惯。它的一个缺陷是如果你偶然忘记了分号会导致一条错误信息：
\begin{minted}{Rust}
    ...
    if preferences.changed() {
        page.compute_size()  // oops, 缺少分号
    }
\end{minted}

如果你在C或者Java程序中犯了这种错误，编译器会简单地直接指出你少写了一个分号。然而这是Rust的报错：
\begin{minted}{text}
    error[E0308]: mismatched types
    22 |         page.compute_size()  // oops, missing semicolon
       |         ^^^^^^^^^^^^^^^^^^^- help: try adding a semicolon `;`
       |         |
       |         expected (), found tuple
       |
       = note: expected unit type `()`
                  found tuple `(u32, u32)`
\end{minted}

在缺少分号的情况下，块的值将是\texttt{page.compute\_size()}返回的值，但一个没有\texttt{else}分支的\texttt{if}语句必须总是返回\texttt{()}。幸运的是，Rust知道这种类型的错误并建议加上分号。

\section{声明}

除了表达式和分号之外，一个块中可能包含任意数量的声明。最常见的情况是\texttt{let}声明，它用来声明局部变量：
\begin{minted}{Rust}
    let name: type = expr;
\end{minted}

类型和初始值是可选的，分号是必须的。

一个\texttt{let}声明可以在不初始化的情况下声明一个变量。这有时很有用，因为有时候一个变量需要在控制流的中途初始化：
\begin{minted}{Rust}
    let name;
    if user.has_nickname() {
        name = user.nickname();
    } else {
        name = generate_unique_name();
        user.register(&name);
    }
\end{minted}

局部变量\texttt{name}有两种不同的初始化路径，但两条路径上它都只会被初始化一次，所以\texttt{name}不需要声明为\texttt{mut}。

在变量初始化之前使用它会导致错误（这和使用被移动的值的错误紧密相关，Rust希望你只在变量的值存在时使用它们！）。

你有时可能会看到代码似乎重新声明一个已经存在的变量，例如：
\begin{minted}{Rust}
    for line in file.lines() {
        let line = line?;
        ...
    }
\end{minted}

\texttt{let}声明创建了一个新的、类型不同的、第二个变量\texttt{line}。第一个\texttt{line}的类型是\texttt{Result<String, io::Error>}，第二个\texttt{line}是一个\texttt{String}。第二个声明在块的剩余部分会取代第一个。这被称为\emph{遮蔽(shadowing)}，在Rust程序中非常常见。上面的代码等价于：
\begin{minted}{Rust}
    for line_result in file.lines() {
        let line = line_result?;
        ...
    }
\end{minted}

在这本书中，我们将坚持在这种场景中使用\texttt{\_result}后缀，来保证变量的名字不同。

一个块还可以包含\emph{item declarations}。一个item是一个可以出现在全局或模块中的声明，例如\texttt{fn}、\texttt{struct}、\texttt{use}。

后面的章节将会详细介绍item。现在，\texttt{fn}足够作为一个例子了。任何块都可以包含\texttt{fn}声明：
\begin{minted}{Rust}
    use std::io;
    use std::cmp::Ordering;

    fn show_files() -> io::Result<()> {
        let mut v = vec![];
        ...
        fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
            a.timestamp.cmp(&b.timestamp)   // 首先，比较时间戳 
                .reverse()                  // 最新的文件优先
                .then(a.path.cmp(&b.path))  // 比较路径
        }

        v.sort_by(cmp_by_timestamp_then_name);
        ...
    }
\end{minted}

当一个\texttt{fn}在块内声明的时候，它的作用域是整个块，它可以在整个块内\emph{使用}。但是一个嵌套的\texttt{fn}不能访问外围作用域的局部变量和参数。例如，函数\texttt{cmp\_by\_timestamp\_then\_name}不能使用\texttt{v}。（Rust还有闭包，闭包可以使用外层作用域的变量，见\hyperref[ch14]{第14章}。）

一个块甚至可以包含整个模块。这听起来可能有些多余了：我们真的需要把语言的\emph{每一部分}嵌套在其他部分中的能力吗？——但程序员（尤其是使用宏的程序员）可以找到语言提供的每一个正交碎片的用法。

\section{if与match}

\section{类型转换}\label{cast}
