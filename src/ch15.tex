\chapter{迭代器}\label{ch15}

\emph{It was the end of a very long day.}

\begin{flushright}
    ——Phil
\end{flushright}

一个\emph{迭代器(iterator)}可以产生一个指的序列，通常会使用一个循环来进行处理。Rust的标准库提供了遍历vector、字符串、哈希表和其他集合的迭代器，以及从一个输入流中产生若干行文本的迭代器、到达网络服务器的连接的迭代器、通过通道从其他线程接收到的值的迭代器，等等。当然，你可以实现自己的迭代器。Rust的\texttt{for}循环提供了一种自然地使用迭代器的语法，但迭代器自身也提供了丰富的方法集合用于映射、过滤、连接、收集等用途。

Rust的迭代器灵活、表达力强、高效。考虑下面的函数，它返回前\texttt{n}个正数的和（通常也被称为\emph{第n个三角数(nth triangle number)}：
\begin{minted}{Rust}
    fn triangle(n: i32) -> i32 {
        let mut sum = 0;
        for i in 1..=n {
            sum += i;
        }
        sum
    }
\end{minted}

表达式\texttt{1..=n}是一个\texttt{RangeInclusive<i32>}值。一个\texttt{RangeInclusive<i32>}是一个产生从起点到终点的所有整数的迭代器（包含起点和终点），因此你可以将它用作\texttt{for}循环的操作数来求\texttt{1}到\texttt{n}的和。

但迭代器也有一个\texttt{fold}方法，你可以使用它实现如下的等价定义：
\begin{minted}{Rust}
    fn triangle(n: i32) -> i32 {
        (1..=n).fold(0, |sum, item| sum + item)
    }
\end{minted}

以\texttt{0}作为起始的总和，\texttt{fold}会获取\texttt{1..=n}产生的每个值，然后用总和和产生的值调用闭包\texttt{|sum, item| sum + item}，每一次闭包的返回值就是新的总和。它最后返回的值就是\texttt{fold}自身返回的值——在这个例子中，就是整个序列的总和。如果你习惯使用\texttt{for}和\texttt{while}循环，那么这看起来会有些奇怪，但一旦你习惯了它，\texttt{fold}就是一个可读性强而简洁的替代方案。

这种写法是函数式编程语言的标准写法，这使得表达式有更强的表现力。但Rsut的迭代器是精心设计的，为了保证编译器可以把它们翻译成优秀的机器代码。在release构建模式下构建上面第二个定义时，Rust知道\texttt{fold}的定义，并且把它内联进\texttt{triangle}。然后，闭包\texttt{|sum, item| sum + item}也会被内联。最后，Rust会检查组合之后的代码，然后发现有一种更简单的方法计算从1到\texttt{n}的和：和总是等于\texttt{n * (n+1) / 2}。Rust会把\texttt{triangle}的整个函数体，包括循环、闭包等所有内容，变成一次乘法指令和一些其他的位运算。

这个例子恰巧可以转换成简单的算术，但在更复杂的使用中迭代器也可以表现的很好。它们是Rust提供灵活抽象的同时只有很小甚至没有开销的另一个例子。

在本章中，我们将会解释：
\begin{itemize}
    \item \texttt{Iterator}和\texttt{IntoIterator} trait，它们是Rust迭代器的基础
    \item 经典迭代器管道的三个阶段：从初始的值创建一个迭代器；通过选择或处理值将一种迭代器变成另一种；消耗迭代器产生的值
    \item 如何为自己的类型实现迭代器
\end{itemize}

迭代器有很多方法，所以一旦你了解了大概的思路，就可以跳过一节。但迭代器在Rust的习惯用法中非常普遍，熟悉这些随附的工具对掌握这门语言至关重要。

\section{\texttt{Iterator}与\texttt{IntoIterator trait}}\label{iter}

一个迭代器是任何实现了\texttt{std::iter::Iterator} trait的类型：
\begin{minted}{Rust}
    trait Iterator {
        type Item;
        fn next(&mut self) -> Option<Self::Item>;
        ... // 很多默认方法
    }
\end{minted}

\texttt{Item}是迭代器产生的值的类型。\texttt{next}方法可能返回\texttt{Some(v)}，其中\texttt{v}是迭代器的下一个值；或者返回\texttt{None}，表示已经到达序列的终点。这里我们省略了\texttt{Iterator}的很多默认方法；我们将在本章的剩余部分分别介绍它们。

如果有一种自然的方法从一个类型上迭代，那么这个类型可以实现\texttt{std::iter::IntoIterator}，它的\texttt{into\_iter}方法获取一个值并返回一个迭代它的迭代器：
\begin{minted}{Rust}
    trait IntoIterator where Self::IntoIter: Iterator<Item=Self::Item> {
        type Item;
        type IntoIter: Iterator;
        fn into_iter(self) -> Self::IntoIter;
    }
\end{minted}

\texttt{IntoIter}是迭代器自身的类型，\texttt{Item}是它产生的值的类型。我们称所有实现了\texttt{IntoIterator}的类型为\emph{可迭代对象(iterable)}，因为你可以迭代它。

Rust的\texttt{for}循环将这些部分漂亮地组合在一起。为了迭代一个迭代器的元素，你可以写：
\begin{minted}{Rust}
    println!("There's:");
    let v = vec!["antimony", "arsenic", "alumium", "selenium"];

    for element in &v {
        println!("{}", element);
    }
\end{minted}

在底层，每一个\texttt{for}循环只是\texttt{IntoIterator}和\texttt{Iterator}的方法调用的缩写：
\begin{minted}{Rust}
    let mut iterator = (&v).into_iter();
    while let Some(element) = iterator.next() {
        println!("{}", element);
    }
\end{minted}

\texttt{for}循环使用了\texttt{IntoIterator::into\_iter}来把操作数\texttt{\&v}转换成一个迭代器，然后重复调用\texttt{Iterator::next}。每一次返回\texttt{Some(element)}时，\texttt{for}循环会执行循环体；如果它返回\texttt{None}，循环会终止。

考虑这个例子，其中有一些迭代器的术语：
\begin{itemize}
    \item 正如我们所说，\emph{迭代器(iterator)}是任何实现了\texttt{Iterator}的类型。
    \item \emph{可迭代对象(iterable)}是任何实现了\texttt{IntoIterator}的类型：你可以通过调用它的\texttt{into\_iter}方法获得一个迭代它的迭代器。这个例子中vector的引用\texttt{\&v}就是可迭代对象。
    \item 一个迭代器\emph{产生(produce)}值。
    \item 迭代器产生的值是\emph{item}。这里，item是\texttt{"antimony", "arsenic}，等等。
    \item 接受迭代器产生的item的代码是\emph{消费者(consumer)}。这个例子中，\texttt{for}循环就是消费者。
\end{itemize}

尽管\texttt{for}循环总是调用操作数的\texttt{into\_iter}，你也可以直接向\texttt{for}循环传递迭代器；例如，当你在\texttt{Range}上循环时就是这种情况。所有的迭代器都会自动实现\texttt{IntoIterator}，它们的\texttt{into\_iter}方法简单地返回迭代器自身。

如果在迭代器返回了\texttt{None}之后，你再调用它的\texttt{next}方法，那么\texttt{Iterator} trait并没有指定这种情况下该怎么做。大多数会再次返回\texttt{None}，但不是所有。（如果这导致了问题，“\nameref{fuse}”中介绍的\texttt{fuse}适配器可能会有帮助。）

\section{创建迭代器}
Rust标准库文档中详细解释了每种类型提供哪些种类的迭代器，但标准库提供了一些通用的约定来帮助你找到需要的迭代器。

\subsection{\texttt{iter}和\texttt{iter\_mut}方法}
大多数集合类型提供\texttt{iter}和\texttt{iter\_mut}方法，它们返回一个迭代器，迭代器会产生每一个item的共享引用或可变引用。数组切片例如\texttt{\&[T]}和\texttt{\&mut [T]}也有\texttt{iter}和\texttt{iter\_mut}方法。除了使用\texttt{for}循环自动处理之外，这些方法是最常用的获得迭代器的方法：
\begin{minted}{Rust}
    let v = vec![4, 20, 12, 8, 6];
    let mut iterator = v.iter();
    assert_eq!(iterator.next(), Some(&4));
    assert_eq!(iterator.next(), Some(&20));
    assert_eq!(iterator.next(), Some(&12));
    assert_eq!(iterator.next(), Some(&8));
    assert_eq!(iterator.next(), Some(&6));
    assert_eq!(iterator.next(), None);
\end{minted}

这个迭代器的item类型是\texttt{\&i32}：每一次调用\texttt{next}都会产生下一个元素的引用，直到到达vector的终点。

每一个类型都可以实现\texttt{iter}和\texttt{iter\_mut}，不管它们实现的方式是什么。\texttt{std::path::Path}的\texttt{iter}返回的迭代器一次产生路径的一段：
\begin{minted}{Rust}
    use std::ffi::OsStr;
    use std::path::Path;

    let path = Path::new("C:/Users/JimB/Downloads/Fedora.iso");
    let mut iterator = path.iter();
    assert_eq!(iterator.next(), Some(OsStr::new("C:")));
    assert_eq!(iterator.next(), Some(OsStr::new("Users")));
    assert_eq!(iterator.next(), Some(OsStr::new("JimB")));
    ...
\end{minted}

这个迭代器的item类型是\texttt{\&std::ffi::OsStr}，它是操作系统调用接受的一种字符串类型的引用切片。

如果某个类型有不止一种迭代方式，那么这个类型通常为每种遍历方式提供特定的方法，因为这时普通的\texttt{iter}方法将会导致歧义。例如，\texttt{\&str}字符串切片类型没有\texttt{iter}方法。作为替代，假设\texttt{s}是\texttt{\&str}，那么\texttt{s.bytes()}返回一个产生\texttt{s}的每个字节的迭代器，而\texttt{s.chars()}会以UTF-8编码解析它的内容，然后产生每一个Unicode字符。

\subsection{\texttt{IntoIterator}实现}
当一个类型实现了\texttt{IntoIterator}之后，你可以自己调用它的\texttt{into\_iter}方法，正如\texttt{for}循环做的一样：
\begin{minted}{Rust}
    // 你通常应该使用HashSet，但它的迭代顺序是不确定的，
    // 因此这个例子中BTreeSet会工作得更好。
    use std::collections::BTreeSet;
    let mut favorites = BTreeSet::new();
    favorites.insert("Lucy in the Sky With Diamonds".to_string());
    favorites.insert("Liebesträume No. 3".to_string());

    let mut it = favorites.into_iter();
    assert_eq!(it.next(), Some("Liebesträume No. 3".to_string()));
    assert_eq!(it.next(), Some("Lucy in the Sky With Diamonds".to_string()));
    assert_eq!(it.next(), None);
\end{minted}

大多数集合实际上都提供了好几个\texttt{IntoIterator}的实现，分别是为共享引用(\texttt{\&T})、可变引用(\texttt{\&mut T})、移动(\texttt{T})提供的实现：
\begin{itemize}
    \item 给定一个集合的\emph{共享引用(shared reference)}，\texttt{into\_iter}返回一个产生item的共享引用的迭代器。例如，在上面的代码中，\texttt{(\&favorites).into\_iter()}将会返回一个\texttt{Item}类型是\texttt{\&String}的迭代器。
    \item 给定一个集合的\emph{可变引用(mutable reference)}，\texttt{into\_iter}返回一个产生item的可变引用的迭代器。例如，如果\texttt{vector}是\texttt{Vec<String>}，那么\texttt{(\&mut vector).into\_iter()}将返回一个\texttt{Item}类型是\texttt{\&mut String}的迭代器。
    \item 当集合\emph{以值}传递时，\texttt{into\_iter}返回一个获取集合所有权并返回item自身的迭代器；item的所有权从集合移动到消费者，原来的集合在这个过程中被消耗。例如，上面代码中的\texttt{favorites.into\_iter()}会返回一个产生每个字符串值的迭代器；消费者会接受每个字符串的所有权。当迭代器被drop时，\texttt{BTreeSet}中剩余的所有元素也都会被drop，并且集合会变为未初始化。
\end{itemize}

因为一个\texttt{for}循环会对操作数调用\texttt{IntoIterator::into\_iter}，这三种实现会导致有下面三种迭代方式：迭代集合的共享引用、迭代集合的可变引用、或者消耗集合并获取它的元素的所有权：
\begin{minted}{Rust}
    for element in &collection { ... }
    for element in &mut collection { ... }
    for element in collection { ... }
\end{minted}

这三种写法会调用上面列出的\texttt{IntoIterator}实现之一。

并不是每个类型都提供了全部这三种实现。例如，\texttt{HashSet}、\texttt{BTreeSet}、\texttt{BinaryHeap}没有实现共享引用的\texttt{IntoIterator}，因为修改它们的元素可能会破坏类型的不变量：修改后的值可能会有不同的哈希值、或者和它的邻居的顺序关系会改变，因此修改元素会导致它们北方在错误的地方。其他的类型支持可变性，但只支持部分。例如，\texttt{HashMap}和\texttt{BTreeMap}产生表项的value的可变引用，以及key的共享引用，原因和上面类似。

一般的准则是迭代应该高效和可预测，因此Rust不提供开销很大或者可能展现出令人惊讶的行为的实现（例如，重新哈希被修改的\texttt{HashSet}条目并因此导致之后的迭代中可能再次遇到它们）。

切片实现了三种\texttt{IntoIterator}变体中的两个；因为它们并不拥有自己引用的元素，因此没有“以值”的实现。作为代替，\texttt{\&[T]}和\texttt{\&mut [T]}的\texttt{into\_iter}返回一个产生共享引用和可变引用的迭代器。如果你把底层切片类型\texttt{[T]}想象成一种集合，那么它就落入了之前的模式。

你可能已经注意到前两种\texttt{IntoIterator}的变体产生共享和可变的引用，这和调用\texttt{iter}或者\texttt{iter\_mut}是等价的。为什么Rust同时提供两者？

\texttt{IntoIterator}让\texttt{for}循环能正常工作，因此它显然是必要的。但当你不使用\texttt{for}循环时，使用\texttt{favorites.iter()}比\texttt{(\&favorites).into\_iter()}更加清晰。你可能会频繁需要以共享引用迭代，因此\texttt{iter}和\texttt{iter\_mut}也很有用。

\texttt{IntoIterator}在泛型代码中也很有用：你可以使用一个约束例如\texttt{T: IntoIterator}来限制类型参数\texttt{T}必须是可以迭代的类型。或者，你可以写\texttt{T: IntoIterator<Item=U>}来进一步要求迭代会产生\texttt{U}类型的值。例如，这个函数打印出任何item可以用\texttt{"{:?}"}格式打印的可迭代对象：
\begin{minted}{Rust}
    use std::fmt::Debug;

    fn dump<T, U>(t: T)
        where T: IntoIterator<Item=U>,
              U: Debug
    {
        for u in t {
            println!("{:?}", u);
        }
    }
\end{minted}
你不能在这个泛型函数中使用\texttt{iter}或者\texttt{iter\_mut}，因为它们不是任何trait的方法：大多数可迭代类型只是恰好有这两个方法。

\subsection{\texttt{from\_fn}和\texttt{successors}}

一个简单而通用的产生一个值序列的方式是提供一个返回它们的闭包。

给定一个返回\texttt{Option<T>}的函数，\texttt{std::iter::from\_fn}返回一个迭代器，它简单地调用那个函数来产生item。例如：
\begin{minted}{Rust}
    use rand::random;   // 在Cargo.toml中添加依赖：rand = "0.7"
    use std::iter::from_fn;
    // 产生1000个随机数，在[0, 1]之间均匀分布。
    // （这并不是你想在`rand_distr` crate中找到的分布，
    // 但你可以很容易地自己实现它）
    let lengths: Vec<f64> =
        from_fn(|| Some((random::<f64>() - random::<f64>()).abs()))
        .take(1000)
        .collect();
\end{minted}

这里调用了\texttt{from\_fn}来制作一个产生随机数的迭代器。因为这个迭代器总是返回\texttt{Some}，因此这个序列永远不会终止，但我们调用了\texttt{take(1000)}来限制只要前1000个元素。然后\texttt{collect}从最后的迭代器构建一个vector。这是一种高效地构建初始化的vector的方式。我们将在本章稍后的“\nameref{BuildColl}”中介绍为什么。

如果每一个item都依赖上一个，那么\texttt{std::iter::successors}函数可以漂亮地工作。你需要提供一个初始item，和一个获取上一个item并返回一个下一个item的\texttt{Option}。如果返回\texttt{None}，那么迭代终止。例如，这里有另一种编写\hyperref[ch02]{第2章}中的曼德勃罗集绘制器的\texttt{escape\_time}函数的方法：
\begin{minted}{Rust}
    use num::Complex;
    use std::iter::successors;

    fn escape_time(c: Complex<f64>, limit: usize) -> Option<usize> {
        let zero = Complex { re: 0.0, im: 0.0 };
        successors(Some(zero), |&z| { Some(z * z + c) })
            .take(limit)
            .enumerate()
            .find(|(_i, z)| z.norm_sqr() > 4.0)
            .map(|(i, _z)| i)
    }
\end{minted}

从zero开始，\texttt{successors}调用通过重复平方再加上参数\texttt{c}来产生一个复平面上点的序列。当绘制曼德勃罗集时，我们希望知道这个序列会一直在原点附近还是远离原点。\texttt{take(limit)}调用设置了序列长度的限制，\texttt{enumerate}为每一个点加上一个序号、把每个点\texttt{z}变为元组\texttt{(i, z)}。然后我们使用\texttt{find}来查找第一个离远点足够远可以逃离的点。如果存在这样的点，\texttt{find}方法返回一个\texttt{Option::Some((i, z))}，否则返回\texttt{None}。\texttt{Option::map}的调用会把\texttt{Some((i, z))}变为\texttt{Some(i)}，但不会改变\texttt{None}：这正是我们想要的返回值。

\texttt{from\_fn}和\texttt{successors}都接受\texttt{FnMut}闭包，因此你的闭包可以捕获并修改作用域中的变量。例如，这个\texttt{fibonacci}函数使用一个\texttt{move}闭包来捕获一个变量并使用它作为运行状态：
\begin{minted}{Rust}
    fn fibonacci() -> impl Iterator<Item=usize> {
        let mut state = (0, 1);
        std::iter::from_fn(move || {
            state = (state.1, state.0 + state.1);
            Some(state.0)
        })
    }

    assert_eq!(fibonacci().take(8).collect::<Vec<_>>(),
               vec![1, 1, 2, 3, 5, 8, 13, 21]);
\end{minted}

注意：\texttt{from\_fn}和\texttt{successors}方法非常灵活，你可以通过传递闭包来达到你想要的行为，并将很多迭代器的使用变为一次对其中一个的调用。但这样做会忽略迭代器提供的表明数据流动和使用标准名称用于通用模式的能力。在你使用这两个函数之前请确保你已经熟悉了本章中的其他迭代器方法，它们通常是更好的完成工的方式。

\subsection{\texttt{drain}方法}
很多集合类型提供一个\texttt{drain}方法来获取集合的可变引用，并返回一个迭代器把每个元素的所有权传递给消费者。然而，和\texttt{into\_iter()}以值获取集合并消耗它不同，\texttt{drain}借用一个集合的可变引用，并且当迭代器被drop时，它会移除集合中剩余的所有元素，让集合变为空。

对于可以用范围索引的类型，例如\texttt{String}、vector、\texttt{VecDeque}，\texttt{drain}方法获取一个要移除的元素的范围，而不是消耗整个序列：
\begin{minted}{Rust}
    use std::iter::FromIterator;

    let mut outer = "Earth".to_string();
    let inner = String::from_iter(outer.dran(1..4));

    assert_eq!(outer, "Eh");
    assert_eq!(inner, "art");
\end{minted}

如果你确实要消耗整个序列，使用整个范围\texttt{..}作为参数。

\subsection{其他迭代器源}
上面的几节基本都是关于像vector和\texttt{HashMap}这样的集合类型的，但标准库中还有很多其他类型支持迭代。\autoref{t15-1}总结了一些有趣的类型，但还有更多没有列出。我们将在专门介绍特定类型的章节（即\hyperref[ch16]{第16章}、\hyperref[ch17]{第17章}、\hyperref[ch18]{第18章}）中详细介绍其中的一些方法。

\begin{longtable}{p{0.22\textwidth}p{0.23\textwidth}p{0.45\textwidth}}
    \caption{标准库中的其他迭代器}
    \label{t15-1}\\
    \hline
    \textbf{类型或trait} & \textbf{表达式} & \textbf{注意} \\
    \hline
    \multirow{2}{*}{\texttt{std::ops::Range}} & \texttt{1..10} & 端点必须是整数才能迭代。包括起点但不包括终点。 \\
    & \texttt{(1..10).step\_by(2)} \cellcolor{tablecolor} & 产生1，3，5，7，9。 \cellcolor{tablecolor} \\
    \hline
    \texttt{std::ops::RangeFrom} & \texttt{1..} & 无限迭代。起点必须是整数。当值到达了这种类型的极限时可能会panic或者溢出。 \\
    \hline
    \rowcolor{tablecolor}
    \texttt{std::ops:: RangeInclusive} & \texttt{1..=10} & 类似\texttt{Range}，但包括终点值。 \\
    \hline
    \texttt{Option<T>} & \texttt{Some(10).iter()} & 类似于一个长度为0(\texttt{None})或1的vector(\texttt{Some(v)})。 \\
    \hline
    \rowcolor{tablecolor}
    \texttt{Result<T, E>} & \texttt{Ok("blah").iter()} & 类似于\texttt{Option}，产生\texttt{Ok}值。 \\
    \hline
    \multirow{7}{*}{\texttt{Vec<T>, \&[T]}} & \texttt{v.windows(16)} & 从左到右产生重叠的、连续的给定长度的切片。 \\
    & \texttt{v.chunks(16)} \cellcolor{tablecolor} & 从左到右产生非重叠的、连续的给定长度的切片。 \cellcolor{tablecolor} \\
    & \texttt{v.chunks\_mut(1024)} & 类似\texttt{chunks}，不过切片是可变的。 \\
    & \texttt{v.split(|byte| byte \& 1 != 0)} \cellcolor{tablecolor} & 产生被满足条件的元素分隔的切片。 \cellcolor{tablecolor} \\
    & \texttt{v.split\_mut(...)} & 同上，但产生可变切片。 \\
    & \texttt{v.rsplit(...)} \cellcolor{tablecolor} & 类似\texttt{split}，但从右向左产生切片。 \cellcolor{tablecolor} \\
    & \texttt{v.splitn(n, ...)} & 类似\texttt{split}，但最多产生\texttt{n}个切片。 \\
    \hline
    \multirow{5}{*}{\texttt{String, \&str}} & \texttt{s.bytes()} \cellcolor{tablecolor} & 产生UTF-8字符串的字节。 \cellcolor{tablecolor} \\
    & \texttt{s.chars()} & 产生UTF-8字符串的\texttt{char}。 \\
    & \texttt{s.split\_whitespace()} \cellcolor{tablecolor} & 以空格分隔字符串，产生非空字符们的切片。 \cellcolor{tablecolor} \\
    & \texttt{s.lines()} & 产生字符串的每一行的切片。 \\
    & \texttt{s.split('/')} \cellcolor{tablecolor} & 用给定的模式分隔字符串，产生每两个匹配之间的内容的切片。模式可以是字符、字符串或者闭包。\cellcolor    {tablecolor} \\
    \hline
    \multirow{5}{*}{\shortstack[l]{\texttt{std::collections::}\\\texttt{HashMap, std::}\\\texttt{collections::BTreeMap}}} & \texttt{s.matches(char:: is\_numeric)} & 产生匹配给定模式的切片。 \\
    & \texttt{map.keys(), map.values()} \cellcolor{tablecolor} & 产生map的key或value的共享引用。 \cellcolor{tablecolor} \\
    & \texttt{map.values\_mut()} & 产生条目的value的可变引用。 \\
    \hline
    \multirow{3}{*}{\shortstack[l]{\texttt{std::collections::}\\\texttt{HashSet, std::}\\\texttt{collections::BTreeSet}}} & \texttt{set1.union(set2)} \cellcolor{tablecolor} & 产生\texttt{set1}和\texttt{set2}的并集的元素的共享引用。 \cellcolor{tablecolor} \\
    & \texttt{set1.intersection(set2)} & 产生\texttt{set1}和\texttt{set2}的交集的元素的共享引用。 \\
    & & \\
    \hline
    \rowcolor{tablecolor}
    \texttt{std::sync::mpsc:: Receiver} & \texttt{rev.iter()} & 产生另一个线程通过相应的\texttt{Sender}发送的值。 \\
    \hline
    \multirow{2}{*}{\texttt{std::io::Read}} & \texttt{stream.bytes()} & 产生来自I/O流的字节。 \\
    & \texttt{stream.chars()} \cellcolor{tablecolor} & 以UTF-8解析流，产生\texttt{char}。 \cellcolor{tablecolor} \\
    \hline
    \multirow{2}{*}{\texttt{std::io::BufRead}} & \texttt{bufstream.lines()} & 以UTF-8解析流，产生\texttt{String}。 \\
    & \texttt{bufstream.split(0)} \cellcolor{tablecolor} & 用给定的字节切分流，产生\texttt{Vec<u8>}缓冲区。 \cellcolor{tablecolor} \\
    \hline
    \texttt{std::fs::ReadDir} & \texttt{std::fs::read\_dir(path)} & 产生目录项。 \\
    \hline
    \rowcolor{tablecolor}
    \texttt{std::net::TcpListener} & \texttt{listener.incoming()} & 产生到来的网络连接。 \\
    \hline
    \multirow{3}{*}{自由函数} & \texttt{std::iter::empty()} & 立即返回\texttt{None}。 \\
    & \texttt{std::iter::once(5)} \cellcolor{tablecolor} & 产生给定值然后结束。 \cellcolor{tablecolor} \\
    & \texttt{std::iter::repeat("\#9")} & 永远产生给定值。 \\
    \hline
\end{longtable}

\section{迭代器适配器}

一旦你得到了一个迭代器，\texttt{Iterator} trait还提供了广泛的\emph{适配器方法(adapter method)}，或者简称为\emph{适配器(adapter)}，它们消耗一个迭代器然后构建一个新的迭代器。为了展示适配器如何工作，我们将从两个最流行的适配器\texttt{map}和\texttt{filter}开始。然后我们会介绍其他的适配器，它们包括几乎所有你能想到的把一个序列的值变成另一个序列的方法：截断、跳过、组合、反向、连接、重复，等等。

\subsection{\texttt{map}的\texttt{filter}}
\texttt{Iterator} trait的\texttt{map}适配器让你通过对每一个item应用一个闭包来产生新迭代器。\texttt{filter}迭代器让你通过一个闭包决定保留哪些item丢弃哪些item，以此过滤迭代器中的某些item。

例如，假设你在迭代文本的每一行，并且想省略每一行的前导和尾部的空格。标准库的\texttt{str::trim}方法排除一个\texttt{\&str}中的前导和尾部空格，返回一个新的新的借用\texttt{\&str}。你可以使用\texttt{map}适配器来对迭代器返回的每一行应用\texttt{str::trim}：
\begin{minted}{Rust}
    let text = "  ponies \n   giraffes\niguanas  \nsquid".to_string();
    let v: Vec<&str> = text.lines()
        .map(str::trim)
        .collect();
    assert_eq!(v, ["ponies", "giraffes", "iguanas", "squid"]);
\end{minted}

\texttt{text.lines()}调用返回一个产生每一行的迭代器。对迭代器调用\texttt{map}返回第二个迭代器，它会对每一行调用\texttt{str::trim}，然后将结果作为产生的item。最后，\texttt{collect}把所有item聚集成一个vector。

当然，\texttt{map}返回的迭代器，本身也可以继续适配。如果你想从结果中排除“iguanas”，你可以像下面这样写：
\begin{minted}{Rust}
    let text = "  ponies \n   giraffes\niguanas  \nsquid".to_string();
    let v: Vec<&str> = text.lines()
        .map(str::trim)
        .filter(|s| *s != "iguanas")
        .collect();
    assert_eq!(v, ["ponies", "giraffes", "squid"]);
\end{minted}

这里\texttt{filter}返回第三个迭代器，只有当\texttt{map}返回的迭代器产生的item调用闭包\texttt{|s| *s != "iguanas"}后返回\texttt{true}时，第三个迭代器才会产生这个item。一个这样的迭代器适配器链就像Unix shell中的管道：每一个适配器都有单个功能，很容易就能看清楚值的序列是如何从左到右转换的。

这两个适配器的签名如下：
\begin{minted}{Rust}
    fn map<B, F>(self, f: ) -> impl Iterator<Item=B>
        where Self: Sized, F: FnMut(Self::Item) -> B;

    fn filter<P>(self, predicate: P) -> impl Iterator<Item=Self::Item>
        where Self: Sized, P: FnMut(&Self::Item) -> bool;
\end{minted}

在标准库中，\texttt{map}和\texttt{filter}实际上返回指定的不透明\texttt{struct}类型，分别是\texttt{std::iter::Map}和\texttt{std::iter::Filter}。然而，它们的名字提供的信息量很少，所以在本书中，我们将用\texttt{-> impl Iterator<Item=...>}来代替，因为它们能告诉我们我们实际想要知道的信息：这个方法返回一个产生给定类型的item的\texttt{Iterator}。

因为大多数适配器以值获取\texttt{self}，所以它们需要\texttt{Self}是\texttt{Sized}（大多数迭代器都是）。

\texttt{map}迭代器会依次把所有item以值传递给闭包，然后把结果返回给消费者。\texttt{filter}迭代器以共享引用把所有的item传递给闭包，保留选中的item的所有权，然后把它们传递给消费者。这就是为什么上面的例子要先解引用\texttt{s}再和\texttt{"iguanas"}比较：\texttt{filter}迭代器的item类型是\texttt{\&str}，所以闭包参数的类型是\texttt{\&\&str}。

有关迭代器适配器有两个重要的点。

首先，在一个迭代器上调用适配器并不会消耗任何item，它只会返回一个新的迭代器，这个迭代器按需处理第一个迭代器产生的item来产生自己的item。在一个适配器链中，唯一会消耗item的方式就是对最后的迭代器调用\texttt{next}。

因此在我们之前的例子中，\texttt{text.lines()}方法调用本身并不从字符串解析行，它只是返回一个迭代器，只有当需要的时候这个迭代器\emph{才会}解析行。类似的，\texttt{map}和\texttt{filter}只是返回需要时\emph{才会}映射或过滤的新迭代器。在最后一个\texttt{collect}开始对\texttt{filter}迭代器调用\texttt{next}之前，将不会有任何计算发生。

当你的适配器有副作用时这一点尤其重要。例如，下面的代码什么也不打印：
\begin{minted}{Rust}
    ["earth", "water", "air", "fire"]
        .iter().map(|elt| println!("{}", elt));
\end{minted}

\texttt{iter}调用返回一个迭代数组元素的迭代器，\texttt{map}调用返回第二个迭代器，第二个迭代器对第一个迭代器产生的每个值调用闭包。但如果整个链中没有要求产生值的操作，那么将不会有\texttt{next}方法被调用。事实上，Rust会警告你这种情况：
\begin{minted}{text}
    warning: unused `std::iter::Map` that must be used
      |
    7 | /     ["earth", "water", "air", "fire"]
    8 | |          .iter().map(|elt| println!("{}", elt));
      | |________________________________________________^
      |
      = note: iterators are lazy and do nothing unless consumed
\end{minted}

错误消息中的术语“lazy”并不是贬义词；它只是对任何直到需要时才进行计算的机制的一种称呼。迭代器应该做最少的必要的工作来满足\texttt{next}调用是Rust的习惯；在这个例子中，并没有\texttt{next}调用，因此不会有任何计算发生。

第二个重要的点是迭代器适配器是0成本抽象。因为\texttt{map}、\texttt{filter}以及它们的同伴都是泛型的，将它们用于迭代器会生成特定迭代器类型的代码。这意味着Rust有足够的信息把每一个迭代器\texttt{next}方法内联到消费者中，然后把整个操作作为一个单元翻译为机器码。因此我们上面展示的\texttt{lines/map/filter}迭代器链和你手写的代码一样高效：
\begin{minted}{Rust}
    for line in text.lines() {
        let line = line.trim();
        if line != "iguanas" {
            v.push(line);
        }
    }
\end{minted}

这一节剩余的部分将介绍\texttt{Iterator} trait可用的适配器。

\subsection{\texttt{filter\_map}和\texttt{flat\_map}}
\texttt{map}适配器适用于一个输入item产生一个输出item的情况。但如果你想删除迭代中的某些item而不是处理它们，或者想将一个item替换成0个或更多的item时该怎么做呢？\texttt{filter\_map}和\texttt{flat\_map}适配器赋予了你这种灵活性。

\texttt{filter\_map}适配器类似于\texttt{map}，除了它的闭包要么将一个item转换成一个新的item（和\texttt{map}一样），要么从迭代中丢弃这个item。因此，它有些像\texttt{filter}和\texttt{map}的结合。它的签名如下：
\begin{minted}{Rust}
    fn filter_map<B, F>(self, f: F) -> impl Iterator<Item=B>
        where Self: Sized, F: FnMut(Self::Item) -> Option<B>;
\end{minted}

除了闭包返回\texttt{Option<B>}之外，而不是\texttt{B}之外，它和\texttt{map}的签名是一样的。当闭包返回\texttt{None}时，这个item会从迭代器中丢弃；当它返回\texttt{Some(b)}时，\texttt{b}就是\texttt{filter\_map}迭代器产生的下一个item。

例如，假设你想扫描一个字符串中空格分隔的单词，找到其中可以被解析为数字的并处理它，然后丢弃其他单词。那你可以写：
\begin{minted}{Rust}
    use std::str::FromStr;

    let text = "1\nfrond .25 289\n3.1415 estuary\n");
    for number in text
        .split_whitespace()
        .filter_map(|w| f64::from_str(w).ok())
    {
        println!("{:4.2}", number.sqrt());
    }
\end{minted}
打印结果如下：
\begin{minted}{text}
    1.00
    0.50
    17.00
    1.77
\end{minted}

传给\texttt{filter\_map}的闭包尝试对每一个空格分隔的切片调用\texttt{f64::from\_str}。这会返回一个\texttt{Result<f64, ParseFloatError>}，它的\texttt{.ok()}返回一个\texttt{Option<f64>}：解析错误变为\texttt{None}，成功的解析会变为\texttt{Some(v)}。\texttt{filter\_map}迭代器丢弃所有的\texttt{None}值，然后对每一个\texttt{Some(v)}产生值\texttt{v}。

但为什么要将\texttt{map}和\texttt{filter}融合成这样的单个操作，而不是直接使用两个适配器？\texttt{filter\_map}适配器适用于刚刚展示过的这种情况，即只有实际尝试处理过item才知道应不应该包含这个item的情况。你可以只用\texttt{filter}和\texttt{map}做到同样的事情，但这样会很笨拙：
\begin{minted}{Rust}
    text.split_whitespace()
        .map(|w| f64::from_str(w))
        .filter(|r| r.is_ok())
        .map(|r| r.unwrap())
\end{minted}

你可以认为\texttt{flat\_map}适配器和\texttt{map}、\texttt{filter\_map}是同一类的，区别在于现在闭包不是只能返回一个item(\texttt{map})或者0或1个item(\texttt{filter\_map})，而是可以返回任意数量的item。\texttt{flat\_map}迭代器产生闭包返回的序列的串联。

\texttt{flat\_map}的签名如下：
\begin{minted}{Rust}
    fn flat_map<U, F>(self, f: F) -> impl Iterator<Item=U::Item>
        where F: FnMut(Self::Item) -> U, U: IntoIterator;
\end{minted}
传给\texttt{flat\_map}的闭包必须返回一个可迭代对象，但任何类型的可迭代对象都可以。\footnote{事实上，因为\texttt{Option}也是一个可迭代对象，行为就像一个有0个或者1个item的序列。所以假设\texttt{closure}返回一个\texttt{Option<T>}，那么\texttt{iterator.filter\_map(closure)}等价于\texttt{iterator.flat\_map(closure)}。}

例如，假设我们有一个把国家映射到主要城市的表。给定一个构架的列表，那我们怎么遍历它们的主要城市？
\begin{minted}{Rust}
    use std::collections::HashMap;

    let mut major_cities = HashMap::new();
    major_cities.insert("Japan", vec!["Tokyo", "Kyoto"]);
    major_cities.insert("The United States", vec!["Portland", "Nashville"]);
    major_cities.insert(""Brazil", vec!["São Paulo", "Brasilia"]);
    major_cities.insert("Kenya", vec!["Nairobi", "Mombasa"]);
    major_cities.insert("The Netherlands", vec!["Amsterdam", "Utrecht"]);

    let countries = ["Japan", "Brazil", "Kenya"];

    for &city in countries.iter().flat_map(|country| &major_cities[country]) {
        println!("{}", city);
    }
\end{minted}
这会打印出下列内容：
\begin{minted}{text}
    Tokyo
    Kyoto
    São Paulo
    Brasilia
    Nairobi
    Mombasa
\end{minted}

这段代码的意思是，对于每一个国家，我们都获取它的城市的vector，然后将所有vector连接成单个序列，然后打印出来。

但记住迭代是惰性的：只有当\texttt{for}循环调用了\texttt{flat\_map}迭代器的\texttt{next}方法时才会开始计算。完全连接的序列从来不会在内存中构造。实际上，这里只有一个小的状态机，对于每一个城市迭代器，一次打印一个item，直到耗尽，然后为下一个国家产生一个新的城市迭代器。效果就类似于嵌套的循环，但被打包用作迭代器。

\subsection{\texttt{flatten}}
\texttt{flatten}适配器把迭代器的item连接起来，假设每一个item都是可迭代对象：
\begin{minted}{Rust}
    use std::collections::BTreeMap;

    // 把城市映射到公园的表：每一个value都是一个vector。
    let mut parks = BTreeMap::new();
    parks.insert("Portland",  vec!["Mt. Tabor Park", "Forest Park"]);
    parks.insert("Kyoto",     vec!["Tadasu-no-Mori Forest", "Maruyama Koen"]);
    parks.insert("Nashville", vec!["Percy Warner Park", "Dargon Park"]);

    // 构建一个所有公园的vector。`values`返回一个产生vector的迭代器，
    // 然后`flatten`按顺序产生每一个vector的元素。
    let all_parks: Vec<_> = parks.values().flatten().cloned().collect();

    assert_eq!(all_parks,
               vec!["Tadasu-no-Mori Forest", "Maruyama Koen", "Percy Warner Park", 
                    "Dragon Park", "Mt. Tabor Park", "Forest Park"]);
\end{minted}

“flatten”这个名字来自于想象把一个两层的结构压扁成一层的结构：\texttt{BTreeMap}和它的\texttt{Vec}的元素被压成一个产生所有元素的迭代器。

\texttt{flatten}的签名如下：
\begin{minted}{Rust}
    fn flatten(self) -> impl Iterator<Item=Self::Item::Item>
        where Self::Item: IntoIterator;
\end{minted}

换句话说，迭代器的item自身必须实现了\texttt{IntoIterator}，这样它才是一个高效的序列的序列。\texttt{flatten}方法返回一个这些序列连接之后的迭代器。当然，这都是惰性完成的，只有当我们迭代完了一个序列才会从\texttt{self}产生一个新的item。

\text{flatten}方法还有一些令人惊讶的用法。如果你有一个\texttt{Vec<Option<...>>}并且你想只迭代其中的\texttt{Some}值，那么\texttt{flatten}可以漂亮地工作：
\begin{minted}{Rust}
    assert_eq!(vec![None, Some("day"), None, Some("one")]
               .into_iter()
               .flatten()
               .collect::<Vec<_>>(),
               vec!["day", "one"]);
\end{minted}

这种方式可以工作是因为\texttt{Option}自身实现了\texttt{IntoIterator}，代表一个有0或1个元素的序列。\texttt{None}元素对迭代过程没有贡献，而每一个\texttt{Some}元素贡献一个值。类似的，你可以使用\texttt{flatten}来迭代\texttt{Option<Vec<...>>}：\texttt{None}和空vector的行为一样。

\texttt{Result}也实现了\texttt{IntoIterator}，\texttt{Err}时代表一个空的序列，因此对一个产生\texttt{Result}值的迭代器调用\texttt{flatten}可以高效地排除所有\texttt{Err}，产生一个解包之后的成功值的序列。我们不推荐在代码中忽略错误，但当用户知道自己在做什么时这是一个巧妙的技巧。

当你需要\texttt{flatten}时你可能会发现你真正需要的是\texttt{flat\_map}。例如，标准库的\texttt{str::to\_uppercase}方法把一个字符串转换成大写，工作方式类似于下面的代码：
\begin{minted}{Rust}
    fn to_uppercase(&self) -> String {
        self.chars()
            .map(char::to_uppercase)
            .flatten() // 有更好的方式
            .collect()
    }
\end{minted}

这里必须使用\texttt{flatten}的原因是\texttt{ch.to\_uppercase()}并不是返回单个字符，而是返回一个可能产生一个或更多字符的迭代器。将每一个字符映射到大写形式会返回一个产生字符迭代器的迭代器，\texttt{flatten}将它们拼接在一起，因此我们最后可以调用\texttt{collect}把它们转换为一个\texttt{String}。

但这种\texttt{map}和\texttt{flatten}的组合使用如此普遍，以至于\texttt{Iterator}提供了\texttt{flat\_map}适配器来处理这种情况。（事实上，\texttt{flat\_map}比\texttt{flatten}更先加入标准库。）因此上面的代码可以写成：
\begin{minted}{Rust}
    fn to_uppercase(&self) -> String {
        self.chars()
            .flat_map(char::to_upeprcase)
            .collect()
    }
\end{minted}




\subsection{\texttt{fuse}}\label{fuse}

\section{消耗迭代器}

\subsection{构建集合：\texttt{collect}和\texttt{FromIterator}}\label{BuildColl}

\section{实现自己的迭代器}