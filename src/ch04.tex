\chapter{所有权与move}\label{ch04}

当提到内存管理，我们希望编程语言能够具备以下两个特点：
\begin{itemize}
    \item 我们希望内存能在我们想要释放的时候被及时释放。这样我们可以控制程序的内存消耗。
    \item 我们永远不希望使用一个指向已经被释放的对象的指针。这会导致未定义行为，进而导致崩溃和安全漏洞。
\end{itemize}

但这两点看起来似乎是相互矛盾的：释放一个还有指针指向的对象的内存必定会导致悬垂指针。几乎所有的主流编程语言都属于两个阵营之一，取决于它们放弃了哪一点：
\begin{itemize}
    \item “安全优先”的阵营使用垃圾回收来管理内存，自动释放那些没有指针指向的对象。这种做法通过将对象一直保持到没有指针指向来避免悬垂指针。几乎所有的现代语言都落入了这个阵营，包括Python、JavaScript、Ruby、Java、C#、Haskell。

    但依赖垃圾回收意味着放弃控制对象被回收的精确时间。通常来说，垃圾收集器令人讨厌，并且理解为什么内存没有如你所料的被释放可能会是一个挑战。

    \item “控制优先”的阵营让你自己负责释放内存。你的程序的内存消耗完全控制在你手中，但如何避免悬垂指针成了你最大的问题。C和C++是这个阵营里仅有的主流语言。

    如果你从没犯过错，那说明你很厉害。但证据表明，你最终还是会犯错。指针的错误使用一直都是那些被报导的安全问题的罪魁祸首。
\end{itemize}

Rust旨在同时保证安全和性能，因此这两种阵营都是不可接受的。但如果兼顾两者很简单的话，早就有人做出来了。要想兼顾两者，必须从根本上作出改变。

Rust以一种令人惊讶的方式打破了这个死锁：严格限制程序使用指针的方法。这一章和接下来将专注于解释这些限制和为什么它们能解决问题。目前，只能说你常用的一些程序结构可能不符合这些规则，你可能需要寻找替代方案。但这些限制的最终效果是给这种混乱带来了足够的秩序，以允许Rust在编译期检查你的程序是否能避免内存安全错误：悬垂指针、两次释放、使用未初始化的内存等。在运行时，你的指针只是简单的地址，就像在C和C++中一样。不同的是你的代码已经被证明是安全的。

这些规则也为Rust实现安全的并发编程奠定了基础。使用Rust精心设计的线程原语，保证内存安全的规则也可以用于保证你的代码可以避免数据竞争。Rust程序中的一个bug不可能导致一个线程破坏另一个线程的数据进而导致在不相干的地方出现很难复现的错误。多线程代码中的不确定行为被那些专为它设计的特性——自选锁、消息通道、院子类型等完全隔离，不会出现在正常的内存访问中。C和C++中的多线程代码臭名昭著，但Rust漂亮的解决了它。

即使有这些限制，你会发现它仍然可以足够灵活地处理几乎所有的任务，而它可以消除内存管理和并发bug的优势将证明你需要改变你需要对自己的风格进行调整。这是Rust最大的赌注，也是它的核心和成功之处。这本书的作者们看好Rust，正是因为我们在C和C++方面有丰富的经验。对我们来说，遵守Rust的规则太容易了。\footnote{译者注：此处原文：For us, Rust's deal is a no-brainer.}

Rust的规则可能和你在其他编程语言中看到的不同。了解怎么和它们一起工作并利用它们的优势，在我们看来是学习Rust的核心挑战。在这一章中，我们将首先展示相同的潜在问题如何在其他语言中导致问题，以此来深入了解Rust规则背后的逻辑和意图。之后，我们将详细解释Rust的规则、从概念和机制层面探究所有权的含义、如何在各种场景下追踪所有权的变化、以及一些为了提供更大的灵活性而打破这些规则的类型。

\section{所有权}

如果你读过C或C++的代码，你可能会看到过有注释说一个某个类的实例\emph{拥有}某些它指向的其他对象。这一般意味着有所有权的对将决定何时释放被拥有的对象：当拥有者被销毁时，它会销毁所有它拥有的对象。

例如，假设你写了如下C++代码：
\begin{minted}{Rust}
    std::string s = "frayed knot";
\end{minted}

字符串\texttt{s}在内存中的表示通常如\hyperref[f4-1][图4-1]所示：
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-1.png}
    \caption{一个栈上的C++ \texttt{std::string}，指向它在堆上分配的内存}
    \label{f4-1}
\end{figure}

这里，实际上\texttt{std::string}对象本身总是只有3个字长，包括一个指向堆上分配的缓冲区的指针、缓冲区的最大容量（也就是在不重新分配缓冲区的情况下，能存储的最大文本长度），和已经持有的文本的长度。这些都是\texttt{std::string}的私有字段，使用者不能访问。

一个\texttt{std::string}拥有它的缓冲区，当程序销毁string时，它的析构函数会释放缓冲区。以前，一些C++库在多个\texttt{std::string}值之间共享单个缓冲区，使用一个引用计数来决定缓冲区什么时候应该被释放。较新版本的C++标准有效地排除了这种表示，所有现代的C++库都是用上图中的方式。

在这些情况下，人们普遍认为，尽管其他代码创建被拥有内存的指针是没问题的，但代码有责任确保在所有者决定销毁它拥有的对象之前所有的指针都已消失。你可以创建一个指向\texttt{std::string}的缓冲区的指针，但当string被销毁后，你的指针就无效了，你必须自己保证不再使用它。拥有者决定所拥有对象的生命周期，所有其他的对象必须尊重它的决定。

我们在这里使用\texttt{std::string}做为例子展示了C++中的所有权是什么样子的：它只是一个标准库普遍遵守的规范，然而即使语言鼓励你也遵守相似的实践，但如何设计你自己的类型最终还是取决于你。

然而在Rust中，所有权的概念被内建在语言之中，并且通过编译期检查确保强制执行。每一个值都只有一个决定它生命周期的所有者。当所有者被释放——Rust中的术语叫\emph{dropped}——它拥有的值也会被dropped。这些规则意味着你可以通过检查代码很容易的查明某个值的生命周期，并给你系统级语言应有的控制生命周期的能力。

一个变量拥有它的值。当控制流离开了变量声明的语法快，变量会被drop，因此它的值也会随之一起drop。例如：
\begin{minted}{Rust}
    fn print_padovan() {
        let mut padovan = vec![1,1,1];  // 在这里分配
        for i in 3..10 {
            let next = padovan[i-3] + padovan[i-2];
            padovan.push(next);
        }
        println!("P(1..10) = {:?}", padovan);
    }
\end{minted}

变量\texttt{padovan}的类型是\texttt{Vec<i32>}，一个32位整数的vector。在内存中，\texttt{padovan}看起来将类似于\hyperref[f4-2]{图4-2}。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-2.png}
    \caption{栈上的\texttt{Vec<i32>}，指向它在堆上的缓冲区}
    \label{f4-2}
\end{figure}

这和我们之前展示的C++的\texttt{std::string}非常像，除了缓冲区里的元素是32位整数，而不是字符。注意存储\texttt{padovan}的指针、容量和长度的字都在\texttt{print\_padovan}函数的栈帧中，只有vector的缓冲区是在堆上分配的。

和之前展示的string \texttt{s}一样，vector拥有它用来存储元素的缓冲区。当变量\texttt{padovan}在函数结尾处离开作用域时，程序会drop这个vector。因为vector拥有它的缓冲区，缓冲区也会随之drop。

Rust的\texttt{Box}类型是另一个所有权的例子。一个\texttt{Box<T>}是一个指向存储在堆上的类型\texttt{T}的值的指针，调用\texttt{Box::new(v)}会在堆上分配一些空间，把值\texttt{v}移动进去，然后返回一个\texttt{Box}指向堆上的空间。因为一个\texttt{Box}拥有它所指向的空间，当\texttt{Box}被drop的时候，堆上的空间也会被释放。

例如，你可以像这样在堆上分配一个元组：
\begin{minted}{Rust}
    {
        let point = Box::new((0.625, 0.5));     // point在这里分配
        let label = format!("{:?}", point);     // label在这里分配
        assert_eq!(label, "(0.625, 0.5)");
    }                                           // point和label都在这里drop
\end{minted}

当程序调用\texttt{Box::new}时，它会在堆上为一个有两个\texttt{f64}值的元组分配空间，把它的参数\texttt{(0.625, 0.5)}移动进去，然后返回一个指向它的指针。当控制流到达\texttt{assert\_eq!}的调用时，栈帧如\hyperref[f4-3]{图4-3}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-3.png}
    \caption{两个本地变量，每个都拥有堆上的一块内存}
    \label{f4-3}
\end{figure}

栈帧本身存储了变量\texttt{point}和\texttt{label}，每一个变量都指向自己拥有的堆上的内存。当它们drop时，它们拥有的内存也随之释放。

类似于变量拥有它们的值一样，结构体拥有它们的字段，元组、数组、vector拥有它们的元素。

\begin{minted}{Rust}
    struct Person { name: String, birth: i32 }
    let mut composers = Vec::new();
    composers.push(Person { name: "Palestrina".to_string(),
                            birth: 1525 });
    composers.push(Person { name: "Dowland".to_string(),
                            birth: 1563 });
    composers.push(Person { name: "Lully".to_string(),
                            birth: 1632 });
    for composer in &composers {
        println!("{}, born {}", composer.name, composer.birth);
    }
\end{minted}

这里，\texttt{composers}是一个\texttt{Vec<Person>}，一个结构体的vector，每个结构体有一个字符串和数字。在内存中，\texttt{composers}的最终结果如\hyperref[f4-4]{图4-4}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-4.png}
    \caption{一个更复杂的所有权树}
    \label{f4-4}
\end{figure}

这里有很多的所有权关系，但每一个都很直观：\texttt{composers}拥有一个vector，vector拥有它的元素，每一个元素是一个\texttt{Person}结构体；每个结构体拥有它的字段；其中的字符串字段拥有它的文本。当控制流离开了\texttt{composers}声明的作用域，程序会drop它的值，同时drop它拥有的所有内容。如果这里还有其他类型的集合，例如\texttt{HashMap}、\texttt{BTreeSet}，那么过程也是一样的。

到这里，让我们退后一步并思考我们到目前为止展示的所有权关系。每个值都只有一个所有者，这样很容易决定什么时候drop这个值。但单个值可能拥有很多其他值：例如，vector \texttt{composers}拥有它的所有元素。这些元素也可能反过来拥有其他值：\texttt{composers}的每个元素拥有一个字符串，字符串又拥有它的文本。

所有者和它们拥有的值组成了\emph{树}：你的拥有者是你的父结点，你拥有的值是你的孩子结点。每棵树的根结点是一个变量；当这个变量离开作用域时，整个树都会随之销毁。我们可以在\texttt{composers}的图中看到这样一棵所有权的树：它不是搜索树数据结构意义上的“树”、也不是DOM元素组成的HTML文档树。相反，我们有一个由混合类型构建的树，Rust的单一所有者规则禁止任何可能使布局变得比树更复杂的连接操作。Rust程序中的每个值都是树中的一个结点，树的根就是变量。

Rust程序通常完全不会像C和C++程序中使用\texttt{free}和\texttt{delete}一样显式drop值。Rust中drop值的方式是将它从所有权树移除：当离开作用域时、或者从vector中删除元素时、或者类似的情况。这时，Rust保证值会和它拥有的所有值一起被drop掉。

在某种意义上，Rust不如其他语言强大：每个其他的编程语言都允许你在对象之间构建任意的关系图，这些对象以你认为合适的方式互相指向。但正因为Rust不够强大，所以它才可以对你的程序进行更强大的分析。Rust的安全保证可以实现的原因就是你的代码中可能出现的所有权关系更加容易处理。这是我们之前提到的Rust的“激进赌注”的一部分：Rust声称，在实践中，解决问题时通常有足够的灵活性来保证至少有一些完美的解决方案可以在语言强加的限制范围内实现。

也就是说，我们到目前为止解释的所有权的概念太过死板以至于很难使用。Rust在以下几个方面扩展了这个简单的想法：
\begin{itemize}
    \item 你可以将值从一个所有者移动到另一个所有者。这允许你构建、更改、拆除所有权树。
    \item 很简单的类型例如整数、浮点数和字符被所有权规则排除在外。它们被称为\texttt{Copy}类型。
    \item 标准库提供了引用计数的指针类型\texttt{Rc}和\texttt{Arc}，它们允许值在一定的限制下可以有多个所有者。
    \item 你可以“借用一个值的引用”，引用是生命周期受限的非占有的指针。
\end{itemize}

这些策略中的每一条都改善了所有权模型的灵活性，同时仍然坚持Rust的承诺。我们将依次介绍它们，引用将在下一章介绍。

















