\chapter{所有权与move}\label{ch04}

当提到内存管理，我们希望编程语言能够具备以下两个特点：
\begin{itemize}
    \item 我们希望内存能在我们想要释放的时候被及时释放。这样我们可以控制程序的内存消耗。
    \item 我们永远不希望使用一个指向已经被释放的对象的指针。这会导致未定义行为，进而导致崩溃和安全漏洞。
\end{itemize}

但这两点看起来似乎是相互矛盾的：释放一个还有指针指向的对象的内存必定会导致悬垂指针。几乎所有的主流编程语言都属于两个阵营之一，取决于它们放弃了哪一点：
\begin{itemize}
    \item “安全优先”的阵营使用垃圾回收来管理内存，自动释放那些没有指针指向的对象。这种做法通过将对象一直保持到没有指针指向来避免悬垂指针。几乎所有的现代语言都落入了这个阵营，包括Python、JavaScript、Ruby、Java、C\#、Haskell。

    但依赖垃圾回收意味着放弃控制对象被回收的精确时间。通常来说，垃圾收集器令人讨厌，并且理解为什么内存没有如你所料的被释放可能会是一个挑战。

    \item “控制优先”的阵营让你自己负责释放内存。你的程序的内存消耗完全控制在你手中，但如何避免悬垂指针成了你最大的问题。C和C++是这个阵营里仅有的主流语言。

    如果你从没犯过错，那说明你很厉害。但证据表明，你最终还是会犯错。指针的错误使用一直都是那些被报导的安全问题的罪魁祸首。
\end{itemize}

Rust旨在同时保证安全和性能，因此这两种阵营都是不可接受的。但如果兼顾两者很简单的话，早就有人做出来了。要想兼顾两者，必须从根本上作出改变。

Rust以一种令人惊讶的方式打破了这个死锁：严格限制程序使用指针的方法。这一章和接下来将专注于解释这些限制和为什么它们能解决问题。目前，只能说你常用的一些程序结构可能不符合这些规则，你可能需要寻找替代方案。但这些限制的最终效果是给这种混乱带来了足够的秩序，以允许Rust在编译期检查你的程序是否能避免内存安全错误：悬垂指针、两次释放、使用未初始化的内存等。在运行时，你的指针只是简单的地址，就像在C和C++中一样。不同的是你的代码已经被证明是安全的。

这些规则也为Rust实现安全的并发编程奠定了基础。使用Rust精心设计的线程原语，保证内存安全的规则也可以用于保证你的代码可以避免数据竞争。Rust程序中的一个bug不可能导致一个线程破坏另一个线程的数据进而导致在不相干的地方出现很难复现的错误。多线程代码中的不确定行为被那些专为它设计的特性——自选锁、消息通道、院子类型等完全隔离，不会出现在正常的内存访问中。C和C++中的多线程代码臭名昭著，但Rust漂亮的解决了它。

即使有这些限制，你会发现它仍然可以足够灵活地处理几乎所有的任务，而它可以消除内存管理和并发bug的优势将证明你需要改变你需要对自己的风格进行调整。这是Rust最大的赌注，也是它的核心和成功之处。这本书的作者们看好Rust，正是因为我们在C和C++方面有丰富的经验。对我们来说，遵守Rust的规则太容易了。\footnote{译者注：此处原文：For us, Rust's deal is a no-brainer.}

Rust的规则可能和你在其他编程语言中看到的不同。了解怎么和它们一起工作并利用它们的优势，在我们看来是学习Rust的核心挑战。在这一章中，我们将首先展示相同的潜在问题如何在其他语言中导致问题，以此来深入了解Rust规则背后的逻辑和意图。之后，我们将详细解释Rust的规则、从概念和机制层面探究所有权的含义、如何在各种场景下追踪所有权的变化、以及一些为了提供更大的灵活性而打破这些规则的类型。

\section{所有权}

如果你读过C或C++的代码，你可能会看到过有注释说一个某个类的实例\emph{拥有}某些它指向的其他对象。这一般意味着有所有权的对将决定何时释放被拥有的对象：当拥有者被销毁时，它会销毁所有它拥有的对象。

例如，假设你写了如下C++代码：
\begin{minted}{Rust}
    std::string s = "frayed knot";
\end{minted}

字符串\texttt{s}在内存中的表示通常如\hyperref[f4-1][图4-1]所示：
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-1.png}
    \caption{一个栈上的C++ \texttt{std::string}，指向它在堆上分配的内存}
    \label{f4-1}
\end{figure}

这里，实际上\texttt{std::string}对象本身总是只有3个字长，包括一个指向堆上分配的缓冲区的指针、缓冲区的最大容量（也就是在不重新分配缓冲区的情况下，能存储的最大文本长度），和已经持有的文本的长度。这些都是\texttt{std::string}的私有字段，使用者不能访问。

一个\texttt{std::string}拥有它的缓冲区，当程序销毁string时，它的析构函数会释放缓冲区。以前，一些C++库在多个\texttt{std::string}值之间共享单个缓冲区，使用一个引用计数来决定缓冲区什么时候应该被释放。较新版本的C++标准有效地排除了这种表示，所有现代的C++库都是用上图中的方式。

在这些情况下，人们普遍认为，尽管其他代码创建被拥有内存的指针是没问题的，但代码有责任确保在所有者决定销毁它拥有的对象之前所有的指针都已消失。你可以创建一个指向\texttt{std::string}的缓冲区的指针，但当string被销毁后，你的指针就无效了，你必须自己保证不再使用它。拥有者决定所拥有对象的生命周期，所有其他的对象必须尊重它的决定。

我们在这里使用\texttt{std::string}做为例子展示了C++中的所有权是什么样子的：它只是一个标准库普遍遵守的规范，然而即使语言鼓励你也遵守相似的实践，但如何设计你自己的类型最终还是取决于你。

然而在Rust中，所有权的概念被内建在语言之中，并且通过编译期检查确保强制执行。每一个值都只有一个决定它生命周期的所有者。当所有者被释放——Rust中的术语叫\emph{dropped}——它拥有的值也会被dropped。这些规则意味着你可以通过检查代码很容易的查明某个值的生命周期，并给你系统级语言应有的控制生命周期的能力。

一个变量拥有它的值。当控制流离开了变量声明的语法快，变量会被drop，因此它的值也会随之一起drop。例如：
\begin{minted}{Rust}
    fn print_padovan() {
        let mut padovan = vec![1,1,1];  // 在这里分配
        for i in 3..10 {
            let next = padovan[i-3] + padovan[i-2];
            padovan.push(next);
        }
        println!("P(1..10) = {:?}", padovan);
    }
\end{minted}

变量\texttt{padovan}的类型是\texttt{Vec<i32>}，一个32位整数的vector。在内存中，\texttt{padovan}看起来将类似于\hyperref[f4-2]{图4-2}。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-2.png}
    \caption{栈上的\texttt{Vec<i32>}，指向它在堆上的缓冲区}
    \label{f4-2}
\end{figure}

这和我们之前展示的C++的\texttt{std::string}非常像，除了缓冲区里的元素是32位整数，而不是字符。注意存储\texttt{padovan}的指针、容量和长度的字都在\texttt{print\_padovan}函数的栈帧中，只有vector的缓冲区是在堆上分配的。

和之前展示的string \texttt{s}一样，vector拥有它用来存储元素的缓冲区。当变量\texttt{padovan}在函数结尾处离开作用域时，程序会drop这个vector。因为vector拥有它的缓冲区，缓冲区也会随之drop。

Rust的\texttt{Box}类型是另一个所有权的例子。一个\texttt{Box<T>}是一个指向存储在堆上的类型\texttt{T}的值的指针，调用\texttt{Box::new(v)}会在堆上分配一些空间，把值\texttt{v}移动进去，然后返回一个\texttt{Box}指向堆上的空间。因为一个\texttt{Box}拥有它所指向的空间，当\texttt{Box}被drop的时候，堆上的空间也会被释放。

例如，你可以像这样在堆上分配一个元组：
\begin{minted}{Rust}
    {
        let point = Box::new((0.625, 0.5));     // point在这里分配
        let label = format!("{:?}", point);     // label在这里分配
        assert_eq!(label, "(0.625, 0.5)");
    }                                           // point和label都在这里drop
\end{minted}

当程序调用\texttt{Box::new}时，它会在堆上为一个有两个\texttt{f64}值的元组分配空间，把它的参数\texttt{(0.625, 0.5)}移动进去，然后返回一个指向它的指针。当控制流到达\texttt{assert\_eq!}的调用时，栈帧如\hyperref[f4-3]{图4-3}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-3.png}
    \caption{两个本地变量，每个都拥有堆上的一块内存}
    \label{f4-3}
\end{figure}

栈帧本身存储了变量\texttt{point}和\texttt{label}，每一个变量都指向自己拥有的堆上的内存。当它们drop时，它们拥有的内存也随之释放。

类似于变量拥有它们的值一样，结构体拥有它们的字段，元组、数组、vector拥有它们的元素。

\begin{minted}{Rust}
    struct Person { name: String, birth: i32 }
    let mut composers = Vec::new();
    composers.push(Person { name: "Palestrina".to_string(),
                            birth: 1525 });
    composers.push(Person { name: "Dowland".to_string(),
                            birth: 1563 });
    composers.push(Person { name: "Lully".to_string(),
                            birth: 1632 });
    for composer in &composers {
        println!("{}, born {}", composer.name, composer.birth);
    }
\end{minted}

这里，\texttt{composers}是一个\texttt{Vec<Person>}，一个结构体的vector，每个结构体有一个字符串和数字。在内存中，\texttt{composers}的最终结果如\hyperref[f4-4]{图4-4}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-4.png}
    \caption{一个更复杂的所有权树}
    \label{f4-4}
\end{figure}

这里有很多的所有权关系，但每一个都很直观：\texttt{composers}拥有一个vector，vector拥有它的元素，每一个元素是一个\texttt{Person}结构体；每个结构体拥有它的字段；其中的字符串字段拥有它的文本。当控制流离开了\texttt{composers}声明的作用域，程序会drop它的值，同时drop它拥有的所有内容。如果这里还有其他类型的集合，例如\texttt{HashMap}、\texttt{BTreeSet}，那么过程也是一样的。

到这里，让我们退后一步并思考我们到目前为止展示的所有权关系。每个值都只有一个所有者，这样很容易决定什么时候drop这个值。但单个值可能拥有很多其他值：例如，vector \texttt{composers}拥有它的所有元素。这些元素也可能反过来拥有其他值：\texttt{composers}的每个元素拥有一个字符串，字符串又拥有它的文本。

所有者和它们拥有的值组成了\emph{树}：你的拥有者是你的父结点，你拥有的值是你的孩子结点。每棵树的根结点是一个变量；当这个变量离开作用域时，整个树都会随之销毁。我们可以在\texttt{composers}的图中看到这样一棵所有权的树：它不是搜索树数据结构意义上的“树”、也不是DOM元素组成的HTML文档树。相反，我们有一个由混合类型构建的树，Rust的单一所有者规则禁止任何可能使布局变得比树更复杂的连接操作。Rust程序中的每个值都是树中的一个结点，树的根就是变量。

Rust程序通常完全不会像C和C++程序中使用\texttt{free}和\texttt{delete}一样显式drop值。Rust中drop值的方式是将它从所有权树移除：当离开作用域时、或者从vector中删除元素时、或者类似的情况。这时，Rust保证值会和它拥有的所有值一起被drop掉。

在某种意义上，Rust不如其他语言强大：每个其他的编程语言都允许你在对象之间构建任意的关系图，这些对象以你认为合适的方式互相指向。但正因为Rust不够强大，所以它才可以对你的程序进行更强大的分析。Rust的安全保证可以实现的原因就是你的代码中可能出现的所有权关系更加容易处理。这是我们之前提到的Rust的“激进赌注”的一部分：Rust声称，在实践中，解决问题时通常有足够的灵活性来保证至少有一些完美的解决方案可以在语言强加的限制范围内实现。

也就是说，我们到目前为止解释的所有权的概念太过死板以至于很难使用。Rust在以下几个方面扩展了这个简单的想法：
\begin{itemize}
    \item 你可以将值从一个所有者移动到另一个所有者。这允许你构建、更改、拆除所有权树。
    \item 很简单的类型例如整数、浮点数和字符被所有权规则排除在外。它们被称为\texttt{Copy}类型。
    \item 标准库提供了引用计数的指针类型\texttt{Rc}和\texttt{Arc}，它们允许值在一定的限制下可以有多个所有者。
    \item 你可以“借用一个值的引用”，引用是生命周期受限的非占有的指针。
\end{itemize}

这些策略中的每一条都改善了所有权模型的灵活性，同时仍然坚持Rust的承诺。我们将依次介绍它们，引用将在下一章介绍。

\section{move}
在Rust里对于大多数类型，赋值给变量、把值传给函数、或者从函数返回值并不会拷贝这个值：它们只会\emph{move}它。源对象放弃了值的所有权，把所有权转移给了目的对象，同时源对象变为未初始化的状态；此时目的对象控制值的生命周期。Rust程序一次一个值、一次一个move的构建和拆除复杂的结构。

你可能会很惊讶Rust改变了这些基础操作的含义。确实赋值操作很早之前就已经有了明确的含义。然而，如果你仔细观察过不同的语言是怎么处理赋值操作的，你就会发现不同语言的处理方式有很大差别。这种差别也让我们能更容易的看出Rust的选择的含义和结果。

考虑下面的Python代码：
\begin{minted}{python}
    s = ['udon', 'ramen', 'soba']
    t = s
    u = s
\end{minted}

每一个Python对象都有一个引用计数，用来追踪当前有多少个值指向它。因此在对\texttt{s}赋值以后，程序的状态如\hyperref[f4-5]{图4-5}所示（注意有一些内容被省略了）。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{../img/f4-5.png}
    \caption{Python如何在内存中表示一个字符串的列表}
    \label{f4-5}
\end{figure}

因为只有\texttt{s}指向列表，所以列表的引用计数是1；因为列表是唯一指向那些字符串的对象，所以每个字符串的引用计数也是1。

当程序执行到\texttt{t}和\texttt{u}的赋值时会发生什么？Python把赋值操作简单实现为让目标变量也指向源变量指向的对象，然后增加对象的引用计数。因此，这段程序的最终状态如\hyperref[f4-6]{图4-6}所示：
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-6.png}
    \caption{在Python里把\texttt{s}赋值给\texttt{t}和\texttt{u}的结果}
    \label{f4-6}
\end{figure}

Python拷贝了\texttt{s}的指针，并赋给了\texttt{t}和\texttt{u}，然后把列表的引用计数更新为3。Python中的赋值开销很低，但因为它创建了新的指向对象的引用，我们必须维护引用计数来知道我们什么时候可以释放值。

现在考虑下面类似的C++代码：
\begin{minted}{C++}
    using namespace std;
    vector<string> s = { "udon", "ramen", "soba" };
    vector<string> t = s;
    vector<string> u = s;
\end{minted}

一开始\texttt{s}的值在内存中如\hyperref[f4-7]{图4-7}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-7.png}
    \caption{C++里一个字符串的vector在内存中的表示}
    \label{f4-7}
\end{figure}

当把\texttt{s}赋值给\texttt{t}和\texttt{u}时会发生什么呢？在C++里赋值一个\texttt{std::vector}会产生一份这个vector的拷贝；\texttt{std::string}的行为类似。因此当程序到达末尾时，它实际上有3个vector和9个字符串（\hyperref[f4-8]{图4-8}）。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-8.png}
    \caption{在C++里把\texttt{s}赋值给\texttt{t}和\texttt{u}的结果}
    \label{f4-8}
\end{figure}

根据值的不同，C++里的赋值可能会消耗任意数量的内存和处理器时间。然而，它的优势是，程序可以很容易的决定何时释放这些内存：当变量离开作用域时，所有这里分配的内存都会被自动释放。

某种意义上，C++和Python选择了相反的策略：Python里赋值操作开销很小，但引用计数（通用一点的说法，垃圾回收）开销很大。C++保持了内存的所有权都很清楚，但赋值时会执行对象的深拷贝导致开销很大。C++程序员通常不太热衷于这种选择：深拷贝可能开销很大，通常会有更好的替代方法。

因此Rust的中的类似程序会怎么做呢？代码如下：
\begin{minted}{Rust}
    let s = vec!["udon".to_string(), "ramen".to_string, "soba".to_string()];
    let t = s;
    let u = s;
\end{minted}

类似于C和C++，Rust把字符串字面量例如\texttt{"udon"}存储在只读内存中，因此，为了更清楚地与C++和Python的例子进行对比，我们调用了\texttt{to\_string}来获得在堆上分配的\texttt{String}值。

在\texttt{s}的初始化之后，因为Rust和C++有相似的vector和string表示，所以看起来和C++中的情况很像（\hyperref[f4-9]{图4-9}）。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-9.png}
    \caption{Rust中一个字符串的vector在内存中的表示}
    \label{f4-9}
\end{figure}

但回想一下，Rust里大多数类型的赋值操作都是把值从源对象\emph{移动}到目的对象，然后源对象变为未初始化的状态。因此\texttt{t}初始化完之后，程序的内存状态如\hyperref[f4-10]{图4-10}所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../img/f4-10.png}
    \caption{Rust里把\texttt{s}赋值给\texttt{t}之后的结果}
    \label{f4-10}
\end{figure}

这里发生了什么？赋值语句\texttt{let t = s;}把vector的三个字段从\texttt{s}移动到了\texttt{t}；现在\texttt{t}拥有了这个vector。vector的元素则仍待在原来的位置，string的位置也没有发生变化。每一个值都只有一个所有者，尽管所有者已经变了。不需要调整引用计数，并且编译器现在把\texttt{s}视作未初始化的状态。

因此当我们到达\texttt{let u = s;}时会发生什么呢？者将会把\texttt{s}的值赋给\texttt{u}。Rust禁止使用未初始化的值，所以编译器会报如下错误：
\begin{minted}{text}
    error[E0382]: use of moved value: `s`
      |
    7 |     let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
      |         - move occurs because `s` has type `Vec<String>`,
      |           which does not implement the `Copy` trait
    8 |     let t = s;
      |             - value moved here
    9 |     let u = s;
      |             ^ value used after move
\end{minted}

考虑Rust在这里使用move的结果。类似于Python，赋值操作开销很小，程序简单的把vector的三个字长的头部从一个点移动到了另一个点。但和C++类似，所有权总是很清晰：程序不需要引用计数或者垃圾回收来判断什么时候释放vector的元素和string的内容。

你为此付出的代价是如果你想要拷贝你必须显式写出。如果你想要最后和C++程序一样的状态，也就是每个变量都有独立的拷贝，那你必须调用vector的\texttt{clone}方法，它会对vector和它的元素执行深拷贝：
\begin{minted}{Rust}
    let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
    let t = s.clone();
    let u = s.clone();
\end{minted}

你也可以通过Rust引用计数指针类型复现Python代码的行为，我们将在“\hyperref[rc]{Rc和Arc：共享所有权}”这一节中简要介绍这一点。

\subsection{更多move的操作}

在我们上面展示的初始化例子中，都是在使用\texttt{let}语句引入变量的同时把值赋给它们。复制给一个变量将与此有细微的不同，如果你把值移动进一个已经被初始化的变量，Rust会drop变量之前的值。例如：
\begin{minted}{Rust}
    let mut s = "Govinda".to_string();
    s = "Siddhartha".to_string();   // 值"Govinda"在这里drop
\end{minted}

在这段代码中，当程序把\texttt{"Siddhartha"}赋值给\texttt{s}时，它之前的值\texttt{"Govinda"}首先被drop掉。但考虑下面的代码：
\begin{minted}{Rust}
    let mut s = "Govinda".to_string();
    let t = s;
    s = "Siddhartha".to_string();   // 这里不会drop任何内容
\end{minted}

这一次，\texttt{t}拿走了\texttt{s}中原本的字符串的所有权，因此当我们给\texttt{s}赋值时，它是未初始化的。在这种场景下，不会发生drop。

我们在这里使用初始化和赋值的例子是因为它们足够简单，但Rust在几乎场景下都使用move。向函数传参会把所有权移动给函数的参数；从函数返回值会把所有权移动给调用者；创建一个元组会把值移动给元组，等等。

你现在可能对我们之前章节给出的例子中到底发生了什么有了更深入的理解。例如，当我们构建作曲家的vector时，我们写了：
\begin{minted}{Rust}
    struct Person { name: String, birth: i32 }

    let mut composers = Vec::new();
    composers.push(Person { name: "Palestrina".to_string(), 
                            birth: 1525 });
\end{minted}

这段代码展示了除了初始化和赋值之外，move发生的几个场景：
\begin{flushleft}
    \emph{从函数返回值}
\end{flushleft}

\hangafter 0
\hangindent 2em
\noindent
\texttt{Vec::new()}的调用会创建一个新的vector并返回，返回的并不是指向vector的指针，而是vector本身：它的所有权从\texttt{Vec::new}移动到了变量\texttt{composers}。类似的，\texttt{to\_string}调用返回了一个新的\texttt{String}实例。

\begin{flushleft}
    \emph{构造新的值}
\end{flushleft}

\hangafter 0
\hangindent 2em
\noindent
新的\texttt{Person}结构体的\texttt{name}字段被\texttt{to\_string}的返回值初始化。结构体获得了这个字符串的所有权。

\begin{flushleft}
    \emph{向函数传递值}
\end{flushleft}

\hangafter 0
\hangindent 2em
\noindent
整个\texttt{Person}结构体，而不是指向它的指针，被传递给vector的\texttt{push}方法，这个方法将值移动到了结构体的尾部。vector获得了\texttt{Person}的所有权，因此也变成了name \texttt{String}的间接所有者。

像这样移动值可能听起来并不是很高效，但有两件事需要记住。第一，move只作用于恰当的值，而不作用于它们拥有的堆存储。对于vector和string来说，\emph{恰当的值}是它们三个字长的头部，潜在的很多元素的数组和文本缓冲区仍然停留在堆中原本的位置。第二，Rust编译器的代码生成部分擅长“看穿”所有这些move；在实践中，机器码通常会直接把值存储到它属于的位置。

\subsection{move和控制流}
之前的例子中的控制流都很简单，move会如何影响更复杂的代码呢？通用的原则是，如果一个变量的值被移动走并且从此之后没有再被赋予一个新的值，那么它被认为是未初始化的。例如，如果一个变量在\texttt{if}表达式的条件判断之后还是有值的，那我们在两个分支中都可以使用它：
\begin{minted}{Rust}
    let x = vec![10, 20, 30];
    if c {
        f(x);   // ... 在这里移动x的值是ok的
    } else {
        g(x);   // ... 在这里移动x的值也是ok的
    }
    h(x);   // 错误：如何任何一个分支使用了x，那么x在此处将是未初始化的
\end{minted}

出于类似的原因，在循环里移动一个变量的值是禁止的：
\begin{minted}{Rust}
    let x = vec![10, 20, 30];
    while f() {
        g(x);   // 错误：x会在第一次迭代时被移动
                // 第二次迭代时就是未初始化状态 
    }
\end{minted}

也就是说，我们需要在每次迭代里都重新赋予它一个新值：
\begin{minted}{Rust}
    let mut x = vec![10, 20, 30];
    while f() {
        g(x);       // 移动x的值
        x = h();    // 给x一个新值
    }
\end{minted}



















